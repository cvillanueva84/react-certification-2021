		Apuntes React

Hola mundo: 

ReactDOM.render(
  <h1>Hello, world!</h1>,
  document.getElementById('root')
);







	
		JSX

Se llama JSX y es una extensión de sintaxis de JavaScript. Recomendamos usarlo con React para describir cómo debería verse la interfaz de usuario. JSX puede recordarle un lenguaje de plantilla, pero viene con todo el poder de JavaScript.


Puede usar comillas para especificar cadenas literales como atributos:

	const element = <div tabIndex="0"></div>;

También puede utilizar llaves para incrustar una expresión de JavaScript en un atributo:
	
	const element = <img src={user.avatarUrl}></img>;


No coloque comillas entre llaves al incrustar una expresión de JavaScript en un atributo. Debe usar comillas (para valores de cadena) o llaves (para expresiones), pero no ambas en el mismo atributo.


Si una etiqueta está vacía, puede cerrarla inmediatamente con />, como XML

Las etiquetas JSX pueden contener elementos secundarios.


JSX previene los ataques de inyección.








		Elementos de renderización


Los elementos son los bloques de construcción más pequeños de las aplicaciones React.

Un elemento describe lo que quiere ver en la pantalla:

	const element = <h1>Hello, world</h1>;


	Renderizando un elemento en el DOM

Digamos que hay un <div>lugar en su archivo HTML:

	<div id="root"></div>

A esto lo llamamos un nodo DOM "raíz" porque todo lo que hay dentro será administrado por React DOM.
Las aplicaciones creadas solo con React suelen tener un único nodo DOM raíz. Si está integrando React en una aplicación existente, puede tener tantos nodos DOM raíz aislados como desee.
Para renderizar un elemento React en un nodo DOM raíz, pase ambos a ReactDOM.render():

	const element = <h1>Hello, world</h1>;
	ReactDOM.render(element, document.getElementById('root'));



		Actualización del elemento renderizado

Los elementos de React son inmutables . Una vez que crea un elemento, no puede cambiar sus hijos o atributos. 
Con nuestro conocimiento hasta ahora, la única forma de actualizar la interfaz de usuario es crear un nuevo elemento y pasarlo a ReactDOM.render().


function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById('root'));
}

setInterval(tick, 1000);










		Componentes y accesorios

Los componentes le permiten dividir la interfaz de usuario en piezas independientes y reutilizables, y pensar en cada pieza de forma aislada. Esta página proporciona una introducción a la idea de componentes.

Conceptualmente, los componentes son como funciones de JavaScript. Aceptan entradas arbitrarias (llamadas "props") y devuelven elementos React que describen lo que debería aparecer en la pantalla.

La forma más sencilla de definir un componente es escribir una función de JavaScript:

	function Welcome(props) {
	  return <h1>Hello, {props.name}</h1>;
	}

Esta función es un componente React válido porque acepta un único argumento de objeto "props" (que significa propiedades) con datos y devuelve un elemento React. Llamamos a estos componentes "componentes de función" porque son, literalmente, funciones de JavaScript.


	Renderizado de un componente 

Anteriormente, solo encontramos elementos React que representan etiquetas DOM:

	const element = <div />;

Sin embargo, los elementos también pueden representar componentes definidos por el usuario:

	const element = <Welcome name="Sara" />;

Cuando React ve un elemento que representa un componente definido por el usuario, pasa atributos JSX y elementos secundarios a este componente como un solo objeto. A este objeto lo llamamos "utilería".


Por ejemplo, este código muestra "Hola, Sara" en la página:

	function Welcome(props) {
	  return <h1>Hello, {props.name}</h1>;
	}

	const element = <Welcome name="Sara" />;
	ReactDOM.render(
	  element,
	  document.getElementById('root')
	);

Recapitulemos lo que sucede en este ejemplo:

1- Llamamos ReactDOM.render()con el <Welcome name="Sara" />elemento.
2- React llama al Welcome componente con {name: 'Sara'}los accesorios.
3- Nuestro Welcomecomponente devuelve un <h1>Hello, Sara</h1>elemento como resultado.
4- React DOM actualiza eficientemente el DOM para que coincida <h1>Hello, Sara</h1>.

Nota: Siempre comience los nombres de los componentes con una letra mayúscula.

React trata los componentes que comienzan con letras minúsculas como etiquetas DOM. Por ejemplo, <div />representa una etiqueta div HTML, pero <Welcome />representa un componente y debe Welcomeestar dentro del alcance.


	Composicion de componentes

Los componentes pueden hacer referencia a otros componentes en su salida. Esto nos permite utilizar la misma abstracción de componentes para cualquier nivel de detalle. Un botón, un formulario, un diálogo, una pantalla: en las aplicaciones React, todos estos se expresan comúnmente como componentes.

Por ejemplo, podemos crear un Appcomponente que se renderice Welcomemuchas veces:

	function Welcome(props) {
	  return <h1>Hello, {props.name}</h1>;
	}

	function App() {
	  return (
	    <div>
	      <Welcome name="Sara" />
	      <Welcome name="Cahal" />
	      <Welcome name="Edite" />
	    </div>
	  );
	}

	ReactDOM.render(
	  <App />,
	  document.getElementById('root')
	);


Por lo general, las nuevas aplicaciones de React tienen un solo Appcomponente en la parte superior. Sin embargo, si integra React en una aplicación existente, puede comenzar de abajo hacia arriba con un pequeño componente como Buttony gradualmente llegar a la parte superior de la jerarquía de vistas.


	Extraer componentes

No tenga miedo de dividir los componentes en componentes más pequeños.

	Los accesorios son de solo lectura

Las funciones se denominan “puras” porque no intentan cambiar sus entradas y siempre devuelven el mismo resultado para las mismas entradas.

Todos los componentes de React deben actuar como funciones puras con respecto a sus accesorios.










	
	Estado y ciclo de vida

En esta sección, aprenderemos cómo hacer que el Clockcomponente sea realmente reutilizable y encapsulado. Configurará su propio temporizador y se actualizará a sí mismo cada segundo.

Podemos comenzar encapsulando cómo se ve el reloj:

	function Clock(props) {
	  return (
	    <div>
	      <h1>Hello, world!</h1>
	      <h2>It is {props.date.toLocaleTimeString()}.</h2>
	    </div>
	  );
	}

	function tick() {
	  ReactDOM.render(
	    <Clock date={new Date()} />,
	    document.getElementById('root')
	  );
	}

	setInterval(tick, 1000);

Sin embargo, pasa por alto un requisito crucial: el hecho de que Clockconfigure un temporizador y actualice la interfaz de usuario cada segundo debería ser un detalle de implementación del Clock.

Idealmente, queremos escribir esto una vez y tener la Clock actualización en sí:

	ReactDOM.render(
	  <Clock />,
	  document.getElementById('root')
	);

Para implementar esto, necesitamos agregar "estado" al Clockcomponente.

El estado es similar a los accesorios, pero es privado y está totalmente controlado por el componente.

	
	Convertir una función en una clase

Puede convertir un componente de función como Clocken una clase en cinco pasos:

1.- Cree una clase ES6 , con el mismo nombre, que se extienda React.Component.
2.- Agregue un único método vacío llamado render().
3.- Mueva el cuerpo de la función al render()método.
4.- Reemplazar propscon this.propsen el render()cuerpo.
5.- Elimina la declaración de función vacía restante.

	class Clock extends React.Component {
	  render() {
	    return (
	      <div>
	        <h1>Hello, world!</h1>
	        <h2>It is {this.props.date.toLocaleTimeString()}.</h2>
	      </div>
	    );
	  }
	}

Clock ahora se define como una clase en lugar de una función.

Se renderllamará al método cada vez que ocurra una actualización, pero siempre que rendericemos <Clock />en el mismo nodo DOM, solo Clockse usará una única instancia de la clase. Esto nos permite utilizar funciones adicionales como el estado local y los métodos de ciclo de vida.


	Agregar un estado local a una clase

Pasaremos datede los apoyos al estado en tres pasos:

1.- Reemplazar this.props.datecon this.state.dateen el render()método:

	class Clock extends React.Component {
	  render() {
	    return (
	      <div>
	        <h1>Hello, world!</h1>
	        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
	      </div>
	    );
	  }
	}

2.- Agregue un constructor de clase que asigne la inicial this.state:

	class Clock extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {date: new Date()};
	  }

	  render() {
	    return (
	      <div>
	        <h1>Hello, world!</h1>
	        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
	      </div>
	    );
	  }
	}


Observe cómo pasamos propsal constructor base:

	  constructor(props) {
	    super(props);
	    this.state = {date: new Date()};
	  }

Los componentes de la clase siempre deben llamar al constructor base con props.

3.- Retire el dateaccesorio del <Clock />elemento:

	ReactDOM.render(
	  <Clock />,
	  document.getElementById('root')
	);

Más tarde, agregaremos el código del temporizador al componente en sí.

El resultado se ve así:

	class Clock extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {date: new Date()};
	  }

	  render() {
	    return (
	      <div>
	        <h1>Hello, world!</h1>
	        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
	      </div>
	    );
	  }
	}

	ReactDOM.render(
	  <Clock />,
	  document.getElementById('root')
	);

A continuación, Clockconfiguraremos su propio temporizador y lo actualizaremos cada segundo.

	
	Agregar métodos de ciclo de vida a una clase

En aplicaciones con muchos componentes, es muy importante liberar los recursos que toman los componentes cuando se destruyen.

Queremos configurar un temporizador cada vez que Clockse procese en el DOM por primera vez. Esto se llama "montaje" en React.

También queremos borrar ese temporizador siempre que se elimine el DOM producido por Clock. Esto se llama "desmontar" en React.

Podemos declarar métodos especiales en la clase del componente para ejecutar algún código cuando un componente se monta y desmonta:

	class Clock extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {date: new Date()};
	  }

	  componentDidMount() {
	  }

	  componentWillUnmount() {
	  }

	  render() {
	    return (
	      <div>
	        <h1>Hello, world!</h1>
	        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
	      </div>
	    );
	  }
	}


Estos métodos se denominan "métodos de ciclo de vida".

El componentDidMount()método se ejecuta después de que la salida del componente se haya procesado en el DOM. Este es un buen lugar para configurar un temporizador:

	  componentDidMount() {
	    this.timerID = setInterval(
	      () => this.tick(),
	      1000
	    );
	  }

Observe cómo guardamos la ID del temporizador directamente en this( this.timerID).

Si bien this.propsReact lo configura y this.statetiene un significado especial, puede agregar campos adicionales a la clase manualmente si necesita almacenar algo que no participa en el flujo de datos (como un ID de temporizador).

Derribaremos el temporizador en el componentWillUnmount()método del ciclo de vida:

	 componentWillUnmount() {
	    clearInterval(this.timerID);
	  }


Finalmente, implementaremos un método llamado tick()que el Clockcomponente se ejecutará cada segundo.

Se utilizará this.setState()para programar actualizaciones para el estado local del componente:

	class Clock extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {date: new Date()};
	  }

	  componentDidMount() {
	    this.timerID = setInterval(
	      () => this.tick(),
	      1000
	    );
	  }

	  componentWillUnmount() {
	    clearInterval(this.timerID);
	  }

	  tick() {
	    this.setState({
	      date: new Date()
	    });
	  }

	  render() {
	    return (
	      <div>
	        <h1>Hello, world!</h1>
	        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
	      </div>
	    );
	  }
	}

	ReactDOM.render(
	  <Clock />,
	  document.getElementById('root')
	);

Ahora el reloj marca cada segundo.

Recapitulemos rápidamente lo que está sucediendo y el orden en que se llaman los métodos:

1.- Cuando <Clock />se pasa a ReactDOM.render(), React llama al constructor del Clockcomponente. Dado que Clocknecesita mostrar la hora actual, se inicializa this.statecon un objeto que incluye la hora actual. Posteriormente actualizaremos este estado.

2.- React luego llama al método Clockdel componente render(). Así es como React aprende lo que debe mostrarse en la pantalla. React luego actualiza el DOM para que coincida con la Clocksalida de renderización.

3.- Cuando la Clock salida se inserta en el DOM, React llama al componentDidMount()método del ciclo de vida. En su interior, el Clockcomponente le pide al navegador que configure un temporizador para llamar al tick()método del componente una vez por segundo.

4.- Cada segundo, el navegador llama al tick()método. En su interior, el Clockcomponente programa una actualización de la interfaz de usuario llamando setState()con un objeto que contiene la hora actual. Gracias a la setState()llamada, React sabe que el estado ha cambiado y render()vuelve a llamar al método para saber qué debería estar en la pantalla. Esta vez, this.state.dateel render()método será diferente, por lo que la salida del render incluirá la hora actualizada. React actualiza el DOM en consecuencia.

5.- Si el Clockcomponente se elimina alguna vez del DOM, React invoca el componentWillUnmount()método del ciclo de vida para detener el temporizador.






		Manejo de eventos

Manejar eventos con elementos React es muy similar a manejar eventos en elementos DOM. Hay algunas diferencias de sintaxis:
-Los eventos de React se nombran usando camelCase, en lugar de minúsculas.
-Con JSX, pasa una función como controlador de eventos, en lugar de una cadena.
		
Por ejemplo, el HTML:

	<button onclick="activateLasers()">
	  Activate Lasers
	</button>

es ligeramente diferente en React:

	<button onClick={activateLasers}>
	  Activate Lasers
	</button>

Otra diferencia es que no puede regresar falsepara evitar el comportamiento predeterminado en React. Debe llamar preventDefaultexplícitamente. Por ejemplo, con HTML simple, para evitar el comportamiento de envío predeterminado del formulario, puede escribir:

	<form onsubmit="console.log('You clicked submit.'); return false">
	  <button type="submit">Submit</button>
	</form>

En React, esto podrìa ser: 

	function Form() {
	  function handleSubmit(e) {
	    e.preventDefault();
	    console.log('You clicked submit.');
	  }

	  return (
	    <form onSubmit={handleSubmit}>
	      <button type="submit">Submit</button>
	    </form>
	  );
	}

Cuando usa React, generalmente no necesita llamar addEventListenerpara agregar oyentes a un elemento DOM después de que se crea. En su lugar, solo proporcione un oyente cuando el elemento se procese inicialmente.

Cuando define un componente usando una clase ES6 , un patrón común es que un controlador de eventos sea un método en la clase. Por ejemplo, este Togglecomponente genera un botón que permite al usuario alternar entre los estados "ON" y "OFF":

	class Toggle extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {isToggleOn: true};

	    // This binding is necessary to make `this` work in the callback
	    this.handleClick = this.handleClick.bind(this);
	  }

	  handleClick() {
	    this.setState(prevState => ({
	      isToggleOn: !prevState.isToggleOn
	    }));
	  }

	  render() {
	    return (
	      <button onClick={this.handleClick}>
	        {this.state.isToggleOn ? 'ON' : 'OFF'}
	      </button>
	    );
	  }
	}

	ReactDOM.render(
	  <Toggle />,
	  document.getElementById('root')
	);

Debe tener cuidado con el significado de las thisdevoluciones de llamada en JSX. En JavaScript, los métodos de clase no están vinculados por defecto. Si te olvidas de enlazar this.handleClicky pasarlo onClick, thisserá undefinedcuando se llame realmente a la función.

Este no es un comportamiento específico de React; es parte de cómo funcionan las funciones en JavaScript . Generalmente, si se refiere a un método sin ()después, como onClick={this.handleClick}, debe vincular ese método.


	Pasar argumentos a los controladores de eventos

Dentro de un bucle, es común querer pasar un parámetro adicional a un controlador de eventos. Por ejemplo, si ides el ID de fila, cualquiera de los siguientes funcionaría:

	<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
	<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>

Las dos líneas anteriores son equivalentes y usan funciones de flecha y Function.prototype.bindrespectivamente.

En ambos casos, el eargumento que representa el evento React se pasará como un segundo argumento después del ID. Con una función de flecha, tenemos que pasarla explícitamente, pero con bindcualquier otro argumento se reenvía automáticamente.












	Representación condicional

En React, puede crear distintos componentes que encapsulan el comportamiento que necesita. Luego, puede renderizar solo algunos de ellos, dependiendo del estado de su aplicación.


La representación condicional en React funciona de la misma manera que las condiciones en JavaScript. Use operadores de JavaScript como ifo el operador condicional para crear elementos que representen el estado actual y deje que React actualice la interfaz de usuario para que coincida con ellos.

Considere estos dos componentes:

	function UserGreeting(props) {
	  return <h1>Welcome back!</h1>;
	}

	function GuestGreeting(props) {
	  return <h1>Please sign up.</h1>;
	}

Crearemos un Greetingcomponente que muestre cualquiera de estos componentes dependiendo de si un usuario está conectado:

	function Greeting(props) {
	  const isLoggedIn = props.isLoggedIn;
	  if (isLoggedIn) {
	    return <UserGreeting />;
	  }
	  return <GuestGreeting />;
	}

	ReactDOM.render(
	  // Try changing to isLoggedIn={true}:
	  <Greeting isLoggedIn={false} />,
	  document.getElementById('root')
	);


Este ejemplo muestra un saludo diferente según el valor de isLoggedInprop.



	Variables de elementos

Puede utilizar variables para almacenar elementos. Esto puede ayudarlo a renderizar condicionalmente una parte del componente mientras que el resto de la salida no cambia.

Considere estos dos nuevos componentes que representan los botones Cerrar sesión e Iniciar sesión:

	function LoginButton(props) {
	  return (
	    <button onClick={props.onClick}>
	      Login
	    </button>
	  );
	}

	function LogoutButton(props) {
	  return (
	    <button onClick={props.onClick}>
	      Logout
	    </button>
	  );
	}


En el siguiente ejemplo, crearemos un componente con estado llamado LoginControl.

Se renderizará <LoginButton />o <LogoutButton />dependiendo de su estado actual. También renderizará un <Greeting />del ejemplo anterior:

	class LoginControl extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleLoginClick = this.handleLoginClick.bind(this);
	    this.handleLogoutClick = this.handleLogoutClick.bind(this);
	    this.state = {isLoggedIn: false};
	  }

	  handleLoginClick() {
	    this.setState({isLoggedIn: true});
	  }

	  handleLogoutClick() {
	    this.setState({isLoggedIn: false});
	  }

	  render() {
	    const isLoggedIn = this.state.isLoggedIn;
	    let button;
	    if (isLoggedIn) {
	      button = <LogoutButton onClick={this.handleLogoutClick} />;
	    } else {
	      button = <LoginButton onClick={this.handleLoginClick} />;
	    }

	    return (
	      <div>
	        <Greeting isLoggedIn={isLoggedIn} />
	        {button}
	      </div>
	    );
	  }
	}

	ReactDOM.render(
	  <LoginControl />,
	  document.getElementById('root')
	);

Si bien declarar una variable y usar una ifdeclaración es una buena manera de renderizar un componente condicionalmente, a veces es posible que desee usar una sintaxis más corta. Hay algunas formas de incorporar condiciones en JSX, que se explican a continuación.



	Inline If con operador lógico &&

Puede incrustar expresiones en JSX envolviéndolas entre llaves. Esto incluye el &&operador lógico de JavaScript . Puede ser útil para incluir condicionalmente un elemento:

	function Mailbox(props) {
	  const unreadMessages = props.unreadMessages;
	  return (
	    <div>
	      <h1>Hello!</h1>
	      {unreadMessages.length > 0 &&
	        <h2>
	          You have {unreadMessages.length} unread messages.
	        </h2>
	      }
	    </div>
	  );
	}

	const messages = ['React', 'Re: React', 'Re:Re: React'];
	ReactDOM.render(
	  <Mailbox unreadMessages={messages} />,
	  document.getElementById('root')
	);


Funciona porque en JavaScript, true && expressionsiempre evalúa expressiony false && expressionsiempre evalúa false.

Por lo tanto, si la condición es true, el elemento inmediatamente posterior &&aparecerá en la salida. Si es así false, React lo ignorará y lo omitirá.

Tenga en cuenta que devolver una expresión falsa seguirá provocando que se omita el elemento after, &&pero devolverá la expresión falsa. En el siguiente ejemplo, <div>0</div>será devuelto por el método render.


	render() {
	  const count = 0;
	  return (
	    <div>
	      { count && <h1>Messages: {count}</h1>}
	    </div>
	  );
	}




	Inline If-Else con operador condicional

Otro método para representar elementos de forma condicional en línea es utilizar el operador condicional de JavaScript condition ? true : false.

En el siguiente ejemplo, lo usamos para renderizar condicionalmente un pequeño bloque de texto.


	render() {
	  const isLoggedIn = this.state.isLoggedIn;
	  return (
	    <div>
	      The user is <b>{isLoggedIn ? 'currently' : 'not'}</b> logged in.
	    </div>
	  );
	}

También se puede usar para expresiones más grandes, aunque es menos obvio lo que está sucediendo:

	render() {
	  const isLoggedIn = this.state.isLoggedIn;
	  return (
	    <div>
	      {isLoggedIn
	        ? <LogoutButton onClick={this.handleLogoutClick} />
	        : <LoginButton onClick={this.handleLoginClick} />
	      }
	    </div>
	  );
	}

Al igual que en JavaScript, depende de usted elegir un estilo apropiado en función de lo que usted y su equipo consideren más legible. Recuerde también que cuando las condiciones se vuelven demasiado complejas, puede ser un buen momento para extraer un componente .



	Evitar que el componente se renderice 

En casos excepcionales, es posible que desee que un componente se oculte aunque haya sido renderizado por otro componente. Para hacer este retorno en nulllugar de su salida de render.

En el siguiente ejemplo, <WarningBanner />se representa según el valor de la propiedad llamada warn. Si el valor de la propiedad es false, entonces el componente no se procesa:

	function WarningBanner(props) {
	  if (!props.warn) {
	    return null;
	  }

	  return (
	    <div className="warning">
	      Warning!
	    </div>
	  );
	}

	class Page extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {showWarning: true};
	    this.handleToggleClick = this.handleToggleClick.bind(this);
	  }

	  handleToggleClick() {
	    this.setState(state => ({
	      showWarning: !state.showWarning
	    }));
	  }

	  render() {
	    return (
	      <div>
	        <WarningBanner warn={this.state.showWarning} />
	        <button onClick={this.handleToggleClick}>
	          {this.state.showWarning ? 'Hide' : 'Show'}
	        </button>
	      </div>
	    );
	  }
	}

	ReactDOM.render(
	  <Page />,
	  document.getElementById('root')
	);

Regresar nulldel rendermétodo de un componente no afecta la activación de los métodos del ciclo de vida del componente. Por ejemplo componentDidUpdate, todavía se llamará.





		Listas y claves 

Primero, repasemos cómo transforma listas en JavaScript.

Dado el código a continuación, usamos la map()función para tomar una matriz numbersy duplicar sus valores. Asignamos la nueva matriz devuelta por map()a la variable doubledy la registramos:

	const numbers = [1, 2, 3, 4, 5];
	const doubled = numbers.map((number) => number * 2);
	console.log(doubled);

Este código se registra [2, 4, 6, 8, 10]en la consola.

En React, transformar matrices en listas de elementos es casi idéntico.


	Renderizado de varios componentes

Puede crear colecciones de elementos e incluirlos en JSX usando llaves {}.

A continuación, recorremos la numbersmatriz utilizando la map()función de JavaScript . Devolvemos un <li>elemento para cada artículo. Finalmente, asignamos la matriz de elementos resultante a listItems:

	const numbers = [1, 2, 3, 4, 5];
	const listItems = numbers.map((number) =>
	  <li>{number}</li>
	);

Incluimos la listItemsmatriz completa dentro de un <ul>elemento y la representamos en el DOM :

	ReactDOM.render(
	  <ul>{listItems}</ul>,
	  document.getElementById('root')
	);

Este código muestra una lista de viñetas de números entre 1 y 5.


	Componente de lista basica 

Por lo general, representaría listas dentro de un componente .

Podemos refactorizar el ejemplo anterior en un componente que acepta una matriz numbers y genera una lista de elementos.

	function NumberList(props) {
	  const numbers = props.numbers;
	  const listItems = numbers.map((number) =>
	    <li>{number}</li>
	  );
	  return (
	    <ul>{listItems}</ul>
	  );
	}

	const numbers = [1, 2, 3, 4, 5];
	ReactDOM.render(
	  <NumberList numbers={numbers} />,
	  document.getElementById('root')
	);


Cuando ejecute este código, recibirá una advertencia de que se debe proporcionar una clave para los elementos de la lista. Una "clave" es un atributo de cadena especial que debe incluir al crear listas de elementos. Discutiremos por qué es importante en la siguiente sección.

Asignemos keya los elementos de nuestra lista en el interior numbers.map()y solucionemos el problema de la clave que falta.

	function NumberList(props) {
	  const numbers = props.numbers;
	  const listItems = numbers.map((number) =>
	    <li key={number.toString()}>
	      {number}
	    </li>
	  );
	  return (
	    <ul>{listItems}</ul>
	  );
	}

	const numbers = [1, 2, 3, 4, 5];
	ReactDOM.render(
	  <NumberList numbers={numbers} />,
	  document.getElementById('root')
	);



	Llaves

Las claves ayudan a React a identificar qué elementos han cambiado, se han agregado o se han eliminado. Se deben dar claves a los elementos dentro de la matriz para darles una identidad estable:

	const numbers = [1, 2, 3, 4, 5];
	const listItems = numbers.map((number) =>
	  <li key={number.toString()}>
	    {number}
	  </li>
	);

La mejor forma de elegir una clave es utilizar una cadena que identifique de forma única un elemento de la lista entre sus hermanos. La mayoría de las veces usaría ID de sus datos como claves:

	const todoItems = todos.map((todo) =>
	  <li key={todo.id}>
	    {todo.text}
	  </li>
	);

Cuando no tenga ID estables para los elementos renderizados, puede usar el índice del elemento como clave como último recurso:

	const todoItems = todos.map((todo, index) =>
	  // Only do this if items have no stable IDs
	  <li key={index}>
	    {todo.text}
	  </li>
	);

No recomendamos utilizar índices para las claves si el orden de los elementos puede cambiar.

Si elige no asignar una clave explícita a los elementos de la lista, React utilizará de forma predeterminada índices como claves.


	Extraer componentes con claves

Las claves solo tienen sentido en el contexto de la matriz circundante.

Por ejemplo, si extrae un ListItemcomponente, debe mantener la clave en los <ListItem />elementos de la matriz en lugar de en el <li>elemento en ListItemsí.

	function ListItem(props) {
	  // Correct! There is no need to specify the key here:
	  return <li>{props.value}</li>;
	}

	function NumberList(props) {
	  const numbers = props.numbers;
	  const listItems = numbers.map((number) =>
	    // Correct! Key should be specified inside the array.
	    <ListItem key={number.toString()} value={number} />
	  );
	  return (
	    <ul>
	      {listItems}
	    </ul>
	  );
	}

	const numbers = [1, 2, 3, 4, 5];
	ReactDOM.render(
	  <NumberList numbers={numbers} />,
	  document.getElementById('root')
	);



Una buena regla general es que los elementos dentro de la map()llamada necesitan claves.


	Las llaves solo deben ser únicas entre hermanos

Las claves sirven como una pista para React pero no pasan a sus componentes. Si necesita el mismo valor en su componente, páselo explícitamente como un accesorio con un nombre diferente:

	const content = posts.map((post) =>
	  <Post
	    key={post.id}
	    id={post.id}
	    title={post.title} />
	);

Con el ejemplo anterior, el Postcomponente puede leer props.id, pero no props.key.




	Inscrustar map() en JSX

En los ejemplos anteriores, declaramos una listItemsvariable separada y la incluimos en JSX:

	function NumberList(props) {
	  const numbers = props.numbers;
	  const listItems = numbers.map((number) =>
	    <ListItem key={number.toString()}
	              value={number} />
	  );
	  return (
	    <ul>
	      {listItems}
	    </ul>
	  );
	}


JSX permite incrustar cualquier expresión entre llaves para que podamos incluir el map()resultado en línea :

	function NumberList(props) {
	  const numbers = props.numbers;
	  return (
	    <ul>
	      {numbers.map((number) =>
	        <ListItem key={number.toString()}
	                  value={number} />
	      )}
	    </ul>
	  );
	}


A veces, esto da como resultado un código más claro, pero también se puede abusar de este estilo. Al igual que en JavaScript, depende de usted decidir si vale la pena extraer una variable para facilitar la lectura. Tenga en cuenta que si el map()cuerpo está demasiado anidado, podría ser un buen momento para extraer un componente .









		Formularios


Los elementos de formulario HTML funcionan de manera un poco diferente a otros elementos DOM en React, porque los elementos de formulario naturalmente mantienen algún estado interno. Por ejemplo, este formulario en HTML simple acepta un solo nombre:

	<form>
	  <label>
	    Name:
	    <input type="text" name="name" />
	  </label>
	  <input type="submit" value="Submit" />
	</form>

Este formulario tiene el comportamiento de formulario HTML predeterminado de navegar a una nueva página cuando el usuario envía el formulario. Si desea este comportamiento en React, simplemente funciona. Pero en la mayoría de los casos, es conveniente tener una función de JavaScript que maneje el envío del formulario y tenga acceso a los datos que el usuario ingresó en el formulario. La forma estándar de lograr esto es con una técnica llamada "componentes controlados".



	Componentes controlados 

En HTML, los elementos de formulario como <input>, <textarea>y <select>normalmente mantienen su propio estado y lo actualizan según la entrada del usuario. En React, el estado mutable generalmente se mantiene en la propiedad de estado de los componentes y solo se actualiza con setState().

Podemos combinar los dos haciendo que el estado React sea la "única fuente de verdad". Luego, el componente React que genera un formulario también controla lo que sucede en ese formulario en la entrada posterior del usuario. Un elemento de formulario de entrada cuyo valor es controlado por React de esta manera se denomina "componente controlado".

Por ejemplo, si queremos que el ejemplo anterior registre el nombre cuando se envía, podemos escribir el formulario como un componente controlado:

	class NameForm extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {value: ''};

	    this.handleChange = this.handleChange.bind(this);
	    this.handleSubmit = this.handleSubmit.bind(this);
	  }

	  handleChange(event) {
	    this.setState({value: event.target.value});
	  }

	  handleSubmit(event) {
	    alert('A name was submitted: ' + this.state.value);
	    event.preventDefault();
	  }

	  render() {
	    return (
	      <form onSubmit={this.handleSubmit}>
	        <label>
	          Name:
	          <input type="text" value={this.state.value} onChange={this.handleChange} />
	        </label>
	        <input type="submit" value="Submit" />
	      </form>
	    );
	  }
	}


Dado que el valueatributo se establece en nuestro elemento de formulario, el valor mostrado siempre será this.state.value, lo que hace que el estado de React sea la fuente de la verdad. Dado que se handleChangeejecuta con cada pulsación de tecla para actualizar el estado de React, el valor mostrado se actualizará a medida que el usuario escriba.

Con un componente controlado, el valor de la entrada siempre es impulsado por el estado React. Si bien esto significa que debe escribir un poco más de código, ahora también puede pasar el valor a otros elementos de la interfaz de usuario o restablecerlo desde otros controladores de eventos.





	









		Composicion vs Herencia 

React tiene un modelo de composición poderoso, y recomendamos usar la composición en lugar de la herencia para reutilizar el código entre componentes.


	Contencion

Algunos componentes no conocen a sus hijos de antemano. Esto es especialmente común para componentes como Sidebaro Dialogque representan "cajas" genéricas.

Recomendamos que dichos componentes utilicen el childrenaccesorio especial para pasar elementos secundarios directamente a su salida:

	function FancyBorder(props) {
	  return (
	    <div className={'FancyBorder FancyBorder-' + props.color}>
	      {props.children}
	    </div>
	  );
	}

Esto permite que otros componentes les pasen hijos arbitrarios anidando el JSX:

	function WelcomeDialog() {
	  return (
	    <FancyBorder color="blue">
	      <h1 className="Dialog-title">
	        Welcome
	      </h1>
	      <p className="Dialog-message">
	        Thank you for visiting our spacecraft!
	      </p>
	    </FancyBorder>
	  );
	}

Todo lo que <FancyBorder>esté dentro de la etiqueta JSX se pasa al FancyBordercomponente como un childrenaccesorio. Dado que se FancyBorderrenderiza {props.children}dentro de a <div>, los elementos pasados ​​aparecen en la salida final.

Si bien esto es menos común, a veces es posible que necesite varios "agujeros" en un componente. En tales casos, puede crear su propia convención en lugar de usar children:

	function SplitPane(props) {
	  return (
	    <div className="SplitPane">
	      <div className="SplitPane-left">
	        {props.left}
	      </div>
	      <div className="SplitPane-right">
	        {props.right}
	      </div>
	    </div>
	  );
	}

	function App() {
	  return (
	    <SplitPane
	      left={
	        <Contacts />
	      }
	      right={
	        <Chat />
	      } />
	  );
	}

Los elementos reaccionan como <Contacts />y <Chat />son solo objetos, por lo que puede pasarlos como accesorios como cualquier otro dato. Este enfoque puede recordarle las "ranuras" en otras bibliotecas, pero no hay limitaciones sobre lo que puede pasar como accesorios en React.


Paso 1: Divida la interfaz de usuario en una jerarquía de componentes
Paso 2: compila una versión estática en React
Paso 3: identificar la representación mínima (pero completa) del estado de la interfaz de usuario
Paso 4: Identifique dónde debería vivir su estado
Paso 5: agregar flujo de datos inverso



	Reglas de Hooks

Los hooks son funciones de JavaScript, pero imponen dos reglas adicionales:

1.- Solo llame a Hooks en el nivel superior . No llame a Hooks dentro de bucles, condiciones o funciones anidadas.

2.- Solo llame a Hooks desde los componentes de la función React . No llame a Hooks desde funciones regulares de JavaScript. (Solo hay otro lugar válido para llamar a Hooks: sus propios Hooks personalizados. Aprenderemos sobre ellos en un momento).








		Reconciliación

React proporciona una API declarativa para que no tenga que preocuparse por los cambios exactos en cada actualización. Esto hace que escribir aplicaciones sea mucho más fácil, pero puede que no sea obvio cómo se implementa en React. Este artículo explica las elecciones que hicimos en el algoritmo de "diferenciación" de React para que las actualizaciones de los componentes sean predecibles y lo suficientemente rápidas para las aplicaciones de alto rendimiento.


	Motivación

Cuando usa React, en un solo momento puede pensar en la render()función como la creación de un árbol de elementos de React. En la próxima actualización de estado o accesorios, esa render()función devolverá un árbol diferente de elementos de React. Luego, React necesita descubrir cómo actualizar de manera eficiente la interfaz de usuario para que coincida con el árbol más reciente.

Existen algunas soluciones genéricas a este problema algorítmico de generar el número mínimo de operaciones para transformar un árbol en otro. Sin embargo, los algoritmos de última generación tienen una complejidad del orden de O (n 3 ) donde n es el número de elementos del árbol.

Si usáramos esto en React, mostrar 1000 elementos requeriría del orden de mil millones de comparaciones. Esto es demasiado caro. En cambio, React implementa un algoritmo heurístico O (n) basado en dos suposiciones:

1.- Dos elementos de diferentes tipos producirán árboles diferentes.
2.- El desarrollador puede insinuar qué elementos secundarios pueden ser estables en diferentes renderizados con un keyaccesorio.

En la práctica, estos supuestos son válidos para casi todos los casos de uso prácticos.


	El algoritmo de diferenciación 

Al diferenciar dos árboles, React primero compara los dos elementos raíz. El comportamiento es diferente según los tipos de elementos raíz.

	
	Elementos de diferentes tipos

Siempre que los elementos raíz tengan diferentes tipos, React derribará el árbol viejo y construirá el nuevo árbol desde cero. Pasar de <a>a <img>, o de <Article>a <Comment>, o de <Button>a <div>: cualquiera de ellos conducirá a una reconstrucción completa.

Al derribar un árbol, los nodos DOM antiguos se destruyen. Las instancias de componentes reciben componentWillUnmount(). Al construir un nuevo árbol, se insertan nuevos nodos DOM en el DOM. Las instancias de componentes reciben UNSAFE_componentWillMount()y luego componentDidMount(). Cualquier estado asociado con el árbol antiguo se pierde.

Cualquier componente debajo de la raíz también se desmontará y se destruirá su estado. Por ejemplo, al diferenciar:

	<div>
	  <Counter />
	</div>

	<span>
	  <Counter />
	</span>

Esto destruirá el viejo Countery volverá a montar uno nuevo.

	
	Elementos DOM del mismo tipo

Al comparar dos elementos DOM de React del mismo tipo, React observa los atributos de ambos, mantiene el mismo nodo DOM subyacente y solo actualiza los atributos modificados. Por ejemplo:

	<div className="before" title="stuff" />

	<div className="after" title="stuff" />

Al comparar estos dos elementos, React sabe que solo debe modificar el classNameen el nodo DOM subyacente.

Al actualizar style, React también sabe actualizar solo las propiedades que cambiaron. Por ejemplo:

	<div style={{color: 'red', fontWeight: 'bold'}} />

	<div style={{color: 'green', fontWeight: 'bold'}} />

Al convertir entre estos dos elementos, React sabe que solo debe modificar el colorestilo, no el fontWeight.

Después de manejar el nodo DOM, React luego recurre a los niños.


	Llaves

Para resolver este problema, React admite un keyatributo. Cuando los niños tienen claves, React usa la clave para hacer coincidir los niños en el árbol original con los niños en el árbol siguiente. Por ejemplo, agregar keya nuestro ejemplo ineficiente anterior puede hacer que la conversión del árbol sea eficiente:

	<ul>
	  <li key="2015">Duke</li>
	  <li key="2016">Villanova</li>
	</ul>

	<ul>
	  <li key="2014">Connecticut</li>
	  <li key="2015">Duke</li>
	  <li key="2016">Villanova</li>
	</ul>


Ahora React sabe que el elemento con clave '2014'es el nuevo, y los elementos con claves '2015'y '2016'se acaban de mover.

En la práctica, encontrar una clave no suele ser difícil. Es posible que el elemento que va a mostrar ya tenga una ID única, por lo que la clave puede provenir de sus datos:


	<li key={item.id}>{item.name}</li>




***********************************************************************************************************************
2.- Intro to Testing
Fuentes:
https://www.guru99.com/test-driven-development.html


			
			What is TDD? (Culture and best practices)



	¿Qué es el desarrollo basado en pruebas (TDD)?


Test Driven Development (TDD) es un enfoque de desarrollo de software en el que se desarrollan casos de prueba para especificar y validar lo que hará el código. En términos simples, los casos de prueba para cada funcionalidad se crean y prueban primero y si la prueba falla, el nuevo código se escribe para pasar la prueba y hacer que el código sea simple y sin errores.

El desarrollo basado en pruebas comienza con el diseño y desarrollo de pruebas para cada pequeña funcionalidad de una aplicación. El marco TDD indica a los desarrolladores que escriban código nuevo solo si una prueba automatizada ha fallado. Esto evita la duplicación de código. La forma completa de TDD es un desarrollo impulsado por pruebas.

El concepto simple de TDD es escribir y corregir las pruebas fallidas antes de escribir código nuevo (antes del desarrollo). Esto ayuda a evitar la duplicación de código, ya que escribimos una pequeña cantidad de código a la vez para pasar las pruebas. (Las pruebas no son más que condiciones de requisitos que debemos probar para cumplirlas).

TDD a veces también se denomina Test First Development.





	Cómo realizar la prueba TDD

Los siguientes pasos definen cómo realizar la prueba TDD:

1.-Agrega una prueba.
2.-Ejecute todas las pruebas y vea si falla alguna nueva.
3.-Escribe un código.
4.-Ejecute pruebas y refactorice el código.
5.-Repetir.



El ciclo TDD Define

1.- Escribe una prueba
2.- Hazlo correr
3.- Cambie el código para hacerlo bien, Refactorizar
4.- Repita el proceso


Algunas aclaraciones sobre TDD:

El enfoque TDD no se trata de "Pruebas" ni de "Diseño".
TDD no significa "escribir algunas de las pruebas y luego construir un sistema que pase las pruebas".
TDD no significa "hacer muchas pruebas".


		
		¿Qué es la aceptación TDD y Developer TDD?



Hay dos niveles de TDD

1.- Aceptación TDD (ATDD): Con ATDD se escribe una única prueba de aceptación. Esta prueba cumple el requisito de la especificación o satisface el comportamiento del sistema. Después de eso, escriba solo el código de producción / funcionalidad suficiente para cumplir con esa prueba de aceptación. La prueba de aceptación se centra en el comportamiento general del sistema. ATDD también se conocía como desarrollo impulsado por el comportamiento (BDD) .

2.- Developer TDD: Con Developer TDD, escribe una prueba de desarrollador única, es decir, una prueba unitaria y luego solo el código de producción suficiente para cumplir con esa prueba. La prueba unitaria se centra en cada pequeña funcionalidad del sistema. El desarrollador TDD simplemente se llama TDD.


--> El objetivo principal de ATDD y TDD es especificar requisitos detallados y ejecutables para su solución justo a tiempo (JIT). JIT significa tomar solo aquellos requisitos en consideración que son necesarios en el sistema. Así que aumente la eficiencia.







		Escalado de TDD a través del desarrollo basado en modelos ágiles (AMDD)


TDD es muy bueno en especificaciones y validaciones detalladas. No puede pensar en problemas más importantes, como el diseño general, el uso del sistema o la interfaz de usuario. AMDD aborda los problemas de escalado ágil que TDD no aborda.

Por lo tanto, AMDD se utiliza para problemas mayores.

En el desarrollo impulsado por modelos (MDD), se crean modelos extensos antes de escribir el código fuente.

Visualizar es uno de los procesos TDD de predecir / imaginar pruebas que se realizarán durante la primera semana del proyecto. El objetivo principal de la visualización es identificar el alcance del sistema y la arquitectura del sistema. Se realizan requisitos de alto nivel y modelado de arquitectura para una visualización exitosa.

Es el proceso en el que no se realiza una especificación detallada del software / sistema, sino que se exploran los requisitos del software / sistema, lo que define la estrategia general del proyecto.


Iteración 0: Visualización
Hay dos sub-activaciones principales.

1.-Previsión de requisitos iniciales.
Puede llevar varios días identificar los requisitos de alto nivel y el alcance del sistema. El enfoque principal es explorar el modelo de uso, el modelo de dominio inicial y el modelo de interfaz de usuario (UI).

2.-Visualización arquitectónica inicial.
También se necesitan varios días para identificar la arquitectura del sistema. Permite establecer orientaciones técnicas para el proyecto. El enfoque principal es explorar diagramas de tecnología, flujo de interfaz de usuario (UI), modelos de dominio y casos de cambio.



	Modelado de iteraciones


Aquí el equipo debe planificar el trabajo que se realizará para cada iteración.

Se utiliza un proceso ágil para cada iteración, es decir, durante cada iteración, se agregará un nuevo elemento de trabajo con prioridad.
Se tendrá en cuenta el primer trabajo de mayor prioridad. Los elementos de trabajo agregados pueden volver a priorizarse o eliminarse de la pila de elementos en cualquier momento.
El equipo analiza cómo van a implementar cada requisito. El modelado se utiliza para este propósito.
El análisis y diseño del modelado se realiza para cada requisito que se va a implementar para esa iteración.




	Modelo de asalto


Esto también se conoce como modelado justo a tiempo.

Aquí la sesión de modelado involucra a un equipo de 2/3 miembros que discuten temas en papel o pizarra.
Un miembro del equipo le pedirá a otro que modele con ellos. Esta sesión de modelado tomará aproximadamente de 5 a 10 minutos. Donde los miembros del equipo se reúnen para compartir pizarra / papel.
Exploran los problemas hasta que no encuentran la causa principal del problema. Justo a tiempo, si un miembro del equipo identifica el problema que quiere resolver, recibirá la ayuda rápida de otros miembros del equipo.
Luego, otros miembros del grupo exploran el problema y luego todos continúan como antes. También se denomina como modelado stand-up o sesiones de control de calidad del cliente.




	Desarrollo basado en pruebas (TDD)


Promueve las pruebas de confirmación del código de su aplicación y la especificación detallada.
Tanto la prueba de aceptación (requisitos detallados) como las pruebas de desarrollador (prueba unitaria) son entradas para TDD.
TDD hace que el código sea más simple y claro. Permite al desarrollador mantener menos documentación.



	Reseñas


Esto es opcional. Incluye inspecciones de códigos y revisiones de modelos.
Esto se puede hacer para cada iteración o para todo el proyecto.
Esta es una buena opción para dar retroalimentación al proyecto.




	Desarrollo impulsado por pruebas (TDD) vs. Desarrollo basado en modelos ágiles (AMDD)

TDD acorta el ciclo de retroalimentación de programación
AMDD acorta el ciclo de retroalimentación de modelado.

TDD es una especificación detallada
AMDD funciona para problemas mayores

TDD promueve el desarrollo de código de alta calidad
AMDD promueve la comunicación de alta calidad con las partes interesadas y los desarrolladores.

TDD habla con programadores
AMDD habla con Business Analyst , partes interesadas y profesionales de datos.

TDD no orientado visualmente
AMDD orientado visualmente

TDD tiene un alcance limitado para trabajos de software
AMDD tiene un alcance amplio que incluye a las partes interesadas. Implica trabajar hacia un entendimiento común

Ambos apoyan el desarrollo evolutivo




		Ventajas de TDD

Las siguientes son las principales ventajas del desarrollo basado en pruebas en ingeniería de software:


	->Notificación temprana de errores.
Los desarrolladores prueban su código, pero en el mundo de las bases de datos, esto a menudo consiste en pruebas manuales o scripts únicos. Con TDD, crea, con el tiempo, un conjunto de pruebas automatizadas que usted y cualquier otro desarrollador pueden volver a ejecutar a voluntad.


	->Código mejor diseñado, más limpio y más extensible.
-Ayuda a comprender cómo se utilizará el código y cómo interactúa con otros módulos.
-Da como resultado una mejor decisión de diseño y un código más mantenible.
-TDD permite escribir código más pequeño con una sola responsabilidad en lugar de procedimientos monolíticos con múltiples responsabilidades. Esto hace que el código sea más sencillo de entender.
-TDD también obliga a escribir solo código de producción para pasar las pruebas según los requisitos del usuario.


	->Confianza para refactorizar
-Si refactoriza el código, puede haber posibilidades de rupturas en el código. Por lo tanto, al tener un conjunto de pruebas automatizadas, puede corregir esas interrupciones antes del lanzamiento. Se dará una advertencia adecuada si se encuentran interrupciones cuando se utilizan pruebas automatizadas.
-El uso de TDD debería dar como resultado un código más rápido y extensible con menos errores que se pueden actualizar con riesgos mínimos.


	->Bueno para el trabajo en equipo
En ausencia de cualquier miembro del equipo, otros miembros del equipo pueden aprender fácilmente y trabajar en el código. También ayuda a compartir conocimientos, lo que hace que el equipo sea más eficaz en general.


	->Bueno para desarrolladores
Aunque los desarrolladores tienen que dedicar más tiempo a escribir casos de prueba TDD, se necesita mucho menos tiempo para depurar y desarrollar nuevas funciones. Escribirás un código más limpio y menos complicado.



	Resumen

-TDD significa desarrollo impulsado por pruebas.
-Significado de TDD: Es un proceso de modificación del código para pasar una prueba diseñada previamente.
-Se hace más hincapié en el código de producción que en el diseño de casos de prueba.
-El desarrollo impulsado por pruebas es un proceso de modificación del código para pasar una prueba diseñada previamente.
-En Ingeniería de Software, a veces se lo conoce como "Prueba Primero Desarrollo".
-Las pruebas TDD incluyen la refactorización de un código, es decir, cambiar / agregar cierta cantidad de código al código existente sin afectar el comportamiento del código.
-Cuando se utiliza la programación TDD, el código se vuelve más claro y fácil de entender.









			Snapshot Testing: https://jestjs.io/docs/snapshot-testing

Las pruebas instantáneas son una herramienta muy útil siempre que desee asegurarse de que su interfaz de usuario no cambie inesperadamente.

Un caso de prueba de instantánea típico representa un componente de la interfaz de usuario, toma una instantánea y luego la compara con un archivo de instantánea de referencia almacenado junto con la prueba. La prueba fallará si las dos instantáneas no coinciden: el cambio es inesperado o la instantánea de referencia debe actualizarse a la nueva versión del componente de la interfaz de usuario.


	Actualización de instantáneas

Es sencillo detectar cuándo falla una prueba de instantánea después de que se ha introducido un error. Cuando eso suceda, siga adelante, solucione el problema y asegúrese de que sus pruebas de instantáneas vuelvan a pasar. Ahora, hablemos del caso en el que una prueba de instantánea falla debido a un cambio de implementación intencional.

	Modo de instantánea interactiva

Las instantáneas fallidas también se pueden actualizar de forma interactiva en el modo de reloj: Menu con opciones

	Instantanea en linea

Las instantáneas en línea se comportan de manera idéntica a las instantáneas externas ( .snaparchivos), excepto que los valores de las instantáneas se vuelven a escribir automáticamente en el código fuente. Esto significa que puede obtener los beneficios de las instantáneas generadas automáticamente sin tener que cambiar a un archivo externo para asegurarse de que se haya escrito el valor correcto.


	Coincidentes de propiedades

A menudo, hay campos en el objeto que desea capturar y que se generan (como ID y fechas). Si intenta tomar una instantánea de estos objetos, forzarán la instantánea a fallar en cada ejecución.Para estos casos, Jest permite proporcionar un comparador asimétrico para cualquier propiedad. Estos comparadores se verifican antes de escribir o probar la instantánea y luego se guardan en el archivo de instantánea en lugar del valor recibido

Cualquier valor dado que no sea un comparador se verificará exactamente y se guardará en la instantánea

	

	Mejores prácticas

Las instantáneas son una herramienta fantástica para identificar cambios inesperados en la interfaz dentro de su aplicación, ya sea que esa interfaz sea una respuesta de API, interfaz de usuario, registros o mensajes de error. Al igual que con cualquier estrategia de prueba, existen algunas prácticas recomendadas que debe conocer y pautas que debe seguir para poder utilizarlas de manera eficaz.

1.- Trate las instantáneas como código
2.- Las pruebas deben ser deterministas
3.- Utilice nombres de instantáneas descriptivas



*******************
Style Components 

const Box = styled(Button)`
	font-size: 1em;
	margin: 1em;
`;

->Media Querys
->Keyframes
->Server Side Rendering 
->Global Styles


# with npm
npm install --save styled-components





















***************************************************************************************************

React testing library 

npm install --save-dev @testing-library/react

Es una solución muy ligero para probar componentes reaccionan. Proporciona funciones de utilidad de luz en 
la parte superior de react-domy react-dom/test-utils, de una manera que alienta mejores prácticas de prueba.

Esta biblioteca fomenta que sus aplicaciones sean más accesibles y le permite acercar sus pruebas al uso de 
sus componentes de la forma en que lo hará un usuario, lo que permite que sus pruebas le den más confianza 
de que su aplicación funcionará cuando un usuario real la use.

Esta biblioteca es un reemplazo de Enzyme . Si bien puede seguir estas pautas utilizando la propia Enzyme, 
hacer cumplir esto es más difícil debido a todas las utilidades adicionales que proporciona Enzyme (utilidades 
que facilitan los detalles de implementación de prueba).

Imports

// import dependencies
import React from 'react'

// import API mocking utilities from Mock Service Worker
import {rest} from 'msw'
import {setupServer} from 'msw/node'

// import react-testing methods
import {render, fireEvent, waitFor, screen} from '@testing-library/react'

// add custom jest matchers from jest-dom
import '@testing-library/jest-dom/extend-expect'
// the component to test
import Fetch from '../fetch'


test('loads and displays greeting', async () => {
  // Arrange
  // Act
  // Assert
})



Mocks 

Utilice la setupServerfunción de mswpara simular una solicitud de API que realiza nuestro componente probado.

// declare which API requests to mock
const server = setupServer(
  // capture "GET /greeting" requests
  rest.get('/greeting', (req, res, ctx) => {
    // respond using a mocked JSON body
    return res(ctx.json({greeting: 'hello there'}))
  }),
)

// establish API mocking before all tests
beforeAll(() => server.listen())
// reset any request handlers that are declared as a part of our tests
// (i.e. for testing one-time error scenarios)
afterEach(() => server.resetHandlers())
// clean up once the tests are done
afterAll(() => server.close())

// ...

test('handlers server error', async () => {
  server.use(
    // override the initial "GET /greeting" request handler
    // to return a 500 Server Error
    rest.get('/greeting', (req, res, ctx) => {
      return res(ctx.status(500))
    }),
  )

  // ...
})







Arrange 

El rendermétodo procesa un elemento React en el DOM.

render ( < Fetch url = " / greeting " /> )  



Act 

El fireEventmétodo le permite disparar eventos para simular acciones del usuario.

fireEvent . haga clic en ( screen . getByText ( 'Cargar saludo' ) )

// esperar hasta que la promesa de solicitud `get` se resuelva y
// el componente llama a setState y vuelve a renderizar.
// `waitFor` espera hasta que la devolución de llamada no arroje un error

esperar esperarPor ( ( ) =>  
  // getByRole arroja un error si no puede encontrar un elemento
  pantalla . getByRole ( 'título' ) ,
)


Assert 

// assert that the alert message is correct using
// toHaveTextContent, a custom matcher from jest-dom.
expect(screen.getByRole('alert')).toHaveTextContent('Oops, failed to fetch!')

// assert that the button is not disabled using
// toBeDisabled, a custom matcher from jest-dom.
expect(screen.getByRole('button')).not.toBeDisabled()


Ejemplo: fetch.js 

import React, {useState, useReducer} from 'react'
import axios from 'axios'

const initialState = {
  error: null,
  greeting: null,
}

function greetingReducer(state, action) {
  switch (action.type) {
    case 'SUCCESS': {
      return {
        error: null,
        greeting: action.greeting,
      }
    }
    case 'ERROR': {
      return {
        error: action.error,
        greeting: null,
      }
    }
    default: {
      return state
    }
  }
}

export default function Fetch({url}) {
  const [{error, greeting}, dispatch] = useReducer(
    greetingReducer,
    initialState,
  )
  const [buttonClicked, setButtonClicked] = useState(false)

  const fetchGreeting = async url =>
    axios
      .get(url)
      .then(response => {
        const {data} = response
        const {greeting} = data
        dispatch({type: 'SUCCESS', greeting})
        setButtonClicked(true)
      })
      .catch(error => {
        dispatch({type: 'ERROR', error})
      })

  const buttonText = buttonClicked ? 'Ok' : 'Load Greeting'

  return (
    <div>
      <button onClick={() => fetchGreeting(url)} disabled={buttonClicked}>
        {buttonText}
      </button>
      {greeting && <h1>{greeting}</h1>}
      {error && <p role="alert">Oops, failed to fetch!</p>}
    </div>
  )
}






Descripción general de las pruebas 

Hay algunas formas de probar los componentes de React. En términos generales, se dividen en dos categorías:

Representar árboles de componentes en un entorno de prueba simplificado y hacer valer sus resultados.
Ejecución de una aplicación completa en un entorno de navegador realista (también conocido como 
pruebas "de un extremo a otro").



Herramientas recomendadas


Jest es un ejecutor de pruebas de JavaScript que le permite acceder al DOM a través dejsdom. Si 
bien jsdom es solo una aproximación de cómo funciona el navegador, a menudo es lo suficientemente 
bueno para probar los componentes de React. Jest proporciona una gran velocidad de iteración combinada 
con funciones poderosas como módulos de simulación y temporizadores para que pueda tener más control 
sobre cómo se ejecuta el código.

React Testing Library es un conjunto de ayudantes que le permiten probar los componentes de React sin 
depender de sus detalles de implementación. Este enfoque hace que la refactorización sea muy sencilla y 
también lo impulsa hacia las mejores prácticas de accesibilidad. Aunque no proporciona una forma de 
renderizar "superficialmente" un componente sin sus hijos, un corredor de pruebas como Jest le permite hacer 
esto burlándose .












API - React testing Library 

React Testing Libraryreexporta todo DOM Testing Library, así como estos métodos:


	render 

function render(
  ui: React.ReactElement<any>,
  options?: {
    /* You won't often use this, expand below for docs on options */
  },
): RenderResult



Render into a container which is appended to document.body.

import {render} from '@testing-library/react';
render(<div />)



import {render} from '@testing-library/react'
import '@testing-library/jest-dom/extend-expect'


test('renders a message', () => {
  const {container, getByText} = render(<Greeting />)
  expect(getByText('Hello, world!')).toBeInTheDocument()
  expect(container.firstChild).toMatchInlineSnapshot(`
    <h1>Hello, World!</h1>
  `)
})



render opciones

A menudo no necesitará especificar opciones, pero si alguna vez lo hace, aquí están las opciones 
disponibles que podría proporcionar como un segundo argumento render.






	container 

De forma predeterminada, React Testing Librarycreará un divy lo agregará dival document.body y aquí 
es donde se renderizará su componente React. Si proporciona su propio elemento HTMLE a containertravés 
de esta opción, no se agregará document.bodyautomáticamente.

Por ejemplo: si está realizando una prueba unitaria de un tablebodyelemento, no puede ser hijo de a div. 
En este caso, puede especificar a tablecomo render container.

const table = document.createElement('table')

const {container} = render(<TableBody {...props} />, {
  container: document.body.appendChild(table),
})



	baseElement 

Si containerse especifica, entonces este valor predeterminado es, de lo contrario, este valor 
predeterminado es document.body. Esto se usa como el elemento base para las consultas, así como lo que se 
imprime cuando lo usa debug().


	hydrate 

Si hydrate se establece en true, se renderizará con ReactDOM.hydrate . Esto puede ser útil si está utilizando 
la representación del lado del servidor y usa ReactDOM.hydrate para montar sus componentes.


	wrapper 

Pase un React Component como la wrapperopción para renderizarlo alrededor del elemento interno. Esto es 
más útil para crear funciones de renderizado personalizadas reutilizables para proveedores de datos comunes. 


	queries

Consultas para enlazar. Reemplaza el conjunto predeterminado de a DOM Testing Librarymenos que se combine.

// Example, a function to traverse table contents
import * as tableQueries from 'my-table-query-libary'
import {queries} from '@testing-library/react'

const {getByRowColumn, getByText} = render(<MyTable />, {
  queries: {...queries, ...tableQueries},
})


Consulte los ayudantes para obtener orientación sobre el uso de funciones de utilidad para crear 
consultas personalizadas.

Las consultas personalizadas también se pueden agregar globalmente siguiendo la guía de renderización personalizada .



	render Resultado 

El render método devuelve un objeto que tiene algunas propiedades: ...queries 

La característica más importante de renderes que las consultas de DOM Testing Library se devuelven 
automáticamente con su primer argumento vinculado al baseElement , que por defecto es document.body.

Ejemplo: 

const {getByLabelText, queryAllByTestId} = render(<Component />)

container 

El nodo DOM que lo contiene de su React Element renderizado (renderizado usando ReactDOM.render). 
Es un div. Este es un nodo DOM normal, por lo que puede llamar, container.querySelectoretc. para inspeccionar 
a los niños.


Consejo: para obtener el elemento raíz de su elemento renderizado, use container.firstChild.




	baseElement 

El nodo DOM contenedor donde se procesa su React Element en el contenedor. Si no especifica 
baseElementen las opciones de render, se utilizará de forma predeterminada document.body.

Esto es útil cuando el componente que desea probar presenta algo fuera del div contenedor, por ejemplo, 
cuando desea realizar una prueba instantánea de su componente del portal, que presenta su HTML directamente 
en el cuerpo.

NOTA: Se recomienda usar screen.debug en su lugar.

Este método es un atajo para console.log(prettyDOM(baseElement)).

import React from 'react'
import {render} from '@testing-library/react'

const HelloWorld = () => <h1>Hello World</h1>
const {debug} = render(<HelloWorld />)
debug()
// <div>
//   <h1>Hello World</h1>
// </div>
// you can also pass an element: debug(getByTestId('messages'))
// and you can pass all the same arguments to debug as you can
// to prettyDOM:
// const maxLengthToPrint = 10000
// debug(getByTestId('messages'), maxLengthToPrint, {highlight: false})

Este es un envoltorio simple alrededor del prettyDOMcual también se expone y de donde proviene DOM Testing Library.





	rerender 

Probablemente sea mejor si prueba el componente que está realizando la actualización de accesorios 
para asegurarse de que los accesorios se actualicen correctamente (consulte la sección Principios rectores ). 
Dicho esto, si prefiere actualizar los accesorios de un componente renderizado en su prueba, esta función se 
puede usar para actualizar los accesorios del componente renderizado.

import {render} from '@testing-library/react'

const {rerender} = render(<NumberDisplay number={1} />)

// re-render the same component with different props
rerender(<NumberDisplay number={2} />)


	unmount 

Esto hará que se desmonte el componente renderizado. Esto es útil para probar lo que sucede cuando su 
componente se elimina de la página (como probar que no deja controladores de eventos dando vueltas causando 
pérdidas de memoria).

Este método es una abstracción bastante pequeña sobre ReactDOM.unmountComponentAtNode

import {render} from '@testing-library/react'

const {container, unmount} = render(<Login />)
unmount()
// your component has been unmounted and now: container.innerHTML === ''




	asFragment

Devuelve una parte DocumentFragmentde su componente renderizado. Esto puede ser útil si necesita 
evitar enlaces en vivo y ver cómo reacciona su componente a los eventos.

import React, {useState} from 'react'
import {render, fireEvent} from '@testing-library/react'

const TestComponent = () => {
  const [count, setCounter] = useState(0)

  return (
    <button onClick={() => setCounter(count => count + 1)}>
      Click to increase: {count}
    </button>
  )
}

const {getByText, asFragment} = render(<TestComponent />)
const firstRender = asFragment()

fireEvent.click(getByText(/Click to increase/))

// This will snapshot only the difference between the first render, and the
// state of the DOM after the click event.
// See https://github.com/jest-community/snapshot-diff
expect(firstRender).toMatchDiffSnapshot(asFragment())



	cleanup

Desmonta árboles de React que se montaron con render .

Tenga en cuenta que esto se hace automáticamente si el marco de prueba que está utilizando es compatible 
con el afterEachglobal y se inyecta en su entorno de prueba (como mocha, Jest y Jasmine). De lo contrario, 
deberá realizar limpiezas manuales después de cada prueba.

Por ejemplo, si está utilizando el marco de pruebas ava , entonces necesitaría usar el test.afterEachgancho de 
esta manera:

import {cleanup, render} from '@testing-library/react'
import test from 'ava'

test.afterEach(cleanup)

test('renders into document', () => {
  render(<div />)
  // ...
})

// ... more tests ...


No llamar cleanupcuando ha llamado renderpodría resultar en una pérdida de memoria y pruebas que no 
son "idempotentes" (lo que puede conducir a errores difíciles de depurar en sus pruebas).





	act 

Este es un envoltorio ligero alrededor de la react-dom/test-utils actfunción . Todo lo que hace es 
reenviar todos los argumentos a la función act si su versión de react es compatible act. Se recomienda 
tilizar la importación de @testing-library/reactmás react-dom/test-utilspor motivos de coherencia.





	About queries 

Las consultas son los métodos que Testing Library le brinda para encontrar elementos en la página. 
Hay varios tipos de consultas ("obtener", "buscar", "consultar"); la diferencia entre ellos es si la consulta 
arrojará un error si no se encuentra ningún elemento o si devolverá una Promesa y volverá a intentarlo. 
Dependiendo del contenido de la página que esté seleccionando, diferentes consultas pueden ser más o menos apropiadas. 

Después de seleccionar un elemento, puede usar la API de eventos o el evento del usuario para activar eventos y 
simular las interacciones del usuario con la página, o usar Jest y jest-dom para hacer afirmaciones sobre el elemento.


Hay métodos auxiliares de la biblioteca de pruebas que funcionan con consultas. A medida que los elementos aparecen 
y desaparecen en respuesta a las acciones, las API de Async como waitForo las findByconsultas se pueden utilizar 
para esperar los cambios en el DOM. Para buscar solo elementos secundarios de un elemento específico, puede 
usar within. Si es necesario, también hay algunas opciones que puede configurar , como el tiempo de espera 
para reintentos y el atributo testID predeterminado.

Ejemplo:

import {render, screen} from '@testing-library/react' // (or /dom, /vue, ...)

test('should show login form', () => {
  render(<Login />)
  const input = screen.getByLabelText('Username')
  // Events and assertions...
})


Tipos de consultas #
Elementos individuales
getBy...: Devuelve el nodo coincidente para una consulta y arroja un error descriptivo si ningún elemento coincide o si se encuentra más de una coincidencia (utilícelo getAllByen su lugar si se espera más de un elemento).
queryBy...: Devuelve el nodo coincidente para una consulta y lo devuelve nullsi ningún elemento coincide. Esto es útil para afirmar un elemento que no está presente. Lanza un error si se encuentra más de una coincidencia (utilícelo queryAllByen su lugar si está bien).
findBy...: Devuelve una Promesa que se resuelve cuando se encuentra un elemento que coincide con la consulta dada. La promesa se rechaza si no se encuentra ningún elemento o si se encuentra más de un elemento después de un tiempo de espera predeterminado de 1000 ms. Si necesita encontrar más de un elemento, use findAllBy.
Elementos múltiples
getAllBy...: Devuelve una matriz de todos los nodos coincidentes para una consulta y arroja un error si ningún elemento coincide.
queryAllBy...: Devuelve una matriz de todos los nodos coincidentes para una consulta y devuelve una matriz vacía ( []) si ningún elemento coincide.
findAllBy...: Devuelve una promesa que se resuelve en una matriz de elementos cuando se encuentran elementos que coinciden con la consulta dada. La promesa se rechaza si no se encuentran elementos después de un tiempo de espera predeterminado de 1000ms.
findByLos métodos son una combinación de getBy*consultas y waitFor. Aceptan las waitForopciones como último argumento (es decir await screen.findByText('text', queryOptions, waitForOptions))


Prioridad #
Según los Principios Rectores , su prueba debe parecerse a la forma en que los usuarios interactúan con su código 
(componente, página, etc.) tanto como sea posible. Teniendo esto en cuenta, recomendamos este orden de prioridad:

Consultas accesibles para todos Consultas que reflejan la experiencia de los usuarios visuales / del mouse, 
así como de aquellos que usan tecnología de asistencia:

getByRole: Se puede utilizar para consultar todos los elementos que se exponen en el árbol de accesibilidad . Con la nameopción puede filtrar los elementos devueltos por su nombre accesible . Esta debería ser su principal preferencia para casi todo. No hay mucho que no pueda obtener con esto (si no puede, es posible que su interfaz de usuario sea inaccesible). Muy a menudo, esto va a ser utilizado con la nameopción de este modo: getByRole('button', {name: /submit/i}). Consulta la lista de roles .
getByLabelText: Este método es realmente bueno para campos de formulario. Al navegar por el formulario de un sitio web, los usuarios encuentran elementos mediante el texto de la etiqueta. Este método emula ese comportamiento, por lo que debería ser su principal preferencia.
getByPlaceholderText: Un marcador de posición no sustituye a una etiqueta . Pero si eso es todo lo que tiene, entonces es mejor que las alternativas.
getByText: Fuera de los formularios, el contenido de texto es la principal forma en que los usuarios encuentran elementos. Este método se puede utilizar para buscar elementos no interactivos (como divs, spans y párrafos).
getByDisplayValue: El valor actual de un elemento de formulario puede ser útil cuando se navega por una página con valores completados.

Consultas semánticas Selectores compatibles con HTML5 y ARIA. Tenga en cuenta que la experiencia del 
usuario al interactuar con estos atributos varía mucho entre los navegadores y la tecnología de asistencia:

getByAltText: Si el elemento es una que los soportes altde texto ( img, areay input), entonces usted puede utilizar esto para encontrar ese elemento.
getByTitle: Los lectores de pantalla no leen el atributo de título de forma constante y no es visible de forma predeterminada para los usuarios videntes.

ID de prueba
getByTestId: El usuario no puede verlos (ni escucharlos), por lo que esto solo se recomienda para los casos en los que no se puede hacer coincidir por rol o texto o no tiene sentido (por ejemplo, el texto es dinámico).


Uso de consultas #
Las consultas base de la biblioteca de pruebas DOM requieren que pase a containercomo primer argumento. 
La mayoría de las implementaciones de framework de Testing Library proporcionan una versión predefinida de 
estas consultas cuando procesa sus componentes con ellas, lo que significa que no tiene que proporcionar un contenedor . Además, si solo desea realizar una consulta document.body, puede usar la screenexportación como se muestra a continuación ( screense recomienda usar ).

El argumento principal de una consulta puede ser una cadena , una expresión regular o una función . 
También hay opciones para ajustar cómo se analiza el texto del nodo. Consulte TextMatch para obtener 
documentación sobre lo que se puede pasar a una consulta.

Dados los siguientes elementos DOM (que pueden ser renderizados por React, Vue, Angular o código HTML simple):

<body>
  <div id="app">
    <label for="username-input">Username</label>
    <input id="username-input" />
  </div>
</body>

Puede usar una consulta para encontrar un elemento (byLabelText, en este caso):

import {screen, getByLabelText} from '@testing-library/dom'

// With screen:
const inputNode1 = screen.getByLabelText('Username')

// Without screen, you need to provide a container:
const container = document.querySelector('#app')
const inputNode2 = getByLabelText(container, 'Username')





	screen 

Todas las consultas exportadas por DOM Testing Library aceptan a containercomo primer argumento. 
Debido a que consultar todo document.bodyes muy común, DOM Testing Library también exporta un screenobjeto 
que tiene todas las consultas que están vinculadas previamente document.body(usando la withinfuncionalidad). 
Los contenedores como React Testing Library se reexportan screenpara que pueda usarlos de la misma manera.

Así es como se usa:

import {render, screen} from '@testing-library/react'

render(
  <div>
    <label htmlFor="example">Example</label>
    <input id="example" />
  </div>,
)

const exampleInput = screen.getByLabelText('Example')

Necesita un entorno DOM global para usar screen. Si está usando jest, con testEnvironment configurado en 
jsdom, un entorno DOM global estará disponible para usted.




	TextMatch 

La mayoría de las API de consulta toman a TextMatchcomo argumento, lo que significa que el 
argumento puede ser una cadena , una expresión regular o una función que devuelve true una coincidencia 
y false una discrepancia.

Ejemplo: 

Dado el siguiente HTML:
< div > Hello World </ div >

Se encuentra el div:

// Matching a string:
screen.getByText('Hello World') // full string match
screen.getByText('llo Worl', {exact: false}) // substring match
screen.getByText('hello world', {exact: false}) // ignore case

// Matching a regex:
screen.getByText(/World/) // substring match
screen.getByText(/world/i) // substring match, ignore case
screen.getByText(/^hello world$/i) // full string match, ignore case
screen.getByText(/Hello W?oRlD/i) // substring match, ignore case, searches for "hello world" or "hello orld"

// Matching with a custom function:
screen.getByText((content, element) => content.startsWith('Hello'))


No encontrará el div: 

// full string does not match
screen.getByText('Goodbye World')

// case-sensitive regex with different case
screen.getByText(/hello world/)

// function looking for a span when it's actually a div:
screen.getByText((content, element) => {
  return element.tagName.toLowerCase() === 'span' && content.startsWith('Hello')
})


Precisión #
Las consultas que toman a TextMatchtambién aceptan un objeto como argumento final que puede contener 
opciones que afectan la precisión de la coincidencia de cadenas:

exact: Predeterminado a true; coincide con cadenas completas, distingue entre mayúsculas y minúsculas. 
Cuando es falso, coincide con subcadenas y no distingue entre mayúsculas y minúsculas.
exactno tiene efecto sobre regexo functionargumentos.
En la mayoría de los casos, el uso de una expresión regular en lugar de una cadena le da más control sobre la coincidencia aproximada y debería preferirse { exact: false }.
normalizer: Una función opcional que anula el comportamiento de normalización.

Ejemplos de normalización : 

Para realizar una coincidencia con el texto sin recortar:

pantalla . getByText ( 'texto' , { 
  normalizador : getDefaultNormalizer ( { trim : false } ) ,  
} )
Para anular la normalización para eliminar algunos caracteres Unicode mientras se mantiene parte (pero no todos) del comportamiento de normalización incorporado:

pantalla . getByText ( 'texto' , { 
  normalizador : str =>  
    getDefaultNormalizer ( { recorte : falso } ) ( str ) . reemplazar ( / [\ u200E- \ u200F] * / g , '' ) ,  
} )



	Depuracion 


screen.debug 

Por conveniencia, la pantalla también expone un debugmétodo además de las consultas. Este método es 
esencialmente un atajo para console.log(prettyDOM()). Admite la depuración del documento, un solo elemento o 
una matriz de elementos.

import {screen} from '@testing-library/dom'

document.body.innerHTML = `
  <button>test</button>
  <span>multi-test</span>
  <div>multi-test</div>
`

// debug document
screen.debug()
// debug single element
screen.debug(screen.getByText('test'))
// debug multiple elements
screen.debug(screen.getAllByText('multi-test'))


screen.logTestingPlaygroundURL()

Para depurar usando testing-playground , la pantalla expone este método conveniente que registra una URL que se puede abrir en un navegador.

importar { screen } desde '@ testing-library / dom'   

documento . cuerpo . innerHTML = `  
  <button> probar </button>
  <span> prueba múltiple </span>
  <div> prueba múltiple </div>
'

// registra el documento completo en testing-playground
pantalla . logTestingPlaygroundURL ( )
// registrar un solo elemento
pantalla . logTestingPlaygroundURL ( screen . getByText ( 'prueba' ) )


*************************************************************

			Hooks 

Son una nueva adición en React 16.8. Te permiten usar el estado y otras funciones de React sin escribir una clase.

import React, { useState } from 'react';

function Example() {
  // Declare a new state variable, which we'll call "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

Los Hooks no reemplazan su conocimiento de los conceptos de React. En cambio, los Hooks proporcionan 
una API más directa a los conceptos de React que ya conoce: accesorios, estado, contexto, referencias 
y ciclo de vida. Como mostraremos más adelante, los Hooks también ofrecen una nueva y poderosa forma de combinarlos.


	Estado hook:

Ejemplo contador:

import React, { useState } from 'react';

function Example() {
  // Declare a new state variable, which we'll call "count"
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}


Aquí useStatehay un gancho (hablaremos sobre lo que esto significa en un momento). Lo 
llamamos dentro de un componente de función para agregarle un estado local. React conservará este 
estado entre re-renderizaciones. useStatedevuelve un par: el valor del estado actual y una función que 
le permite actualizarlo. Puede llamar a esta función desde un controlador de eventos o desde otro lugar. 
Es similar a this.setStateuna clase, excepto que no fusiona el estado antiguo y el nuevo. (Vamos a mostrar 
un ejemplo comparando useStatea this.stateen Usando el gancho Estado .)

El único argumento para useStatees el estado inicial. En el ejemplo anterior, es 0porque nuestro contador 
comienza desde cero. Tenga en cuenta que this.state, a diferencia de esto , el estado aquí no tiene que ser 
un objeto, aunque puede serlo si lo desea. El argumento de estado inicial solo se usa durante el primer renderizado.


Declarar múltiples variables de estado


Puede utilizar State Hook más de una vez en un solo componente:

function ExampleWithManyStates() {
  // Declare multiple state variables!
  const [age, setAge] = useState(42);
  const [fruit, setFruit] = useState('banana');
  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);
  // ...
}

La sintaxis de desestructuración de matrices nos permite dar diferentes nombres a las variables 
de estado que declaramos llamando useState. Estos nombres no forman parte de la useStateAPI. En cambio, 
React asume que si llamas useStatemuchas veces, lo haces en el mismo orden durante cada render.

¿Qué es un Hook? 

Son funciones que le permiten "conectarse" al estado de React y las características del ciclo de vida de los 
componentes de la función. Los hooks no funcionan dentro de las clases, te permiten usar React sin clases. 




UseEffect

useEffect, agrega la capacidad de realizar efectos secundarios desde un componente de función. 
Tiene el mismo propósito que componentDidMount, componentDidUpdatey componentWillUnmounten las clases React, 
pero unificado en una única API. (Mostraremos ejemplos que se comparan useEffectcon estos métodos en Uso del 
gancho de efectos ).

Por ejemplo, este componente establece el título del documento después de que React actualice el DOM:

import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // Similar to componentDidMount and componentDidUpdate:
  useEffect(() => {
    // Update the document title using the browser API
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

Cuando llama useEffect, le está diciendo a React que ejecute su función de "efecto" después de eliminar 
los cambios en el DOM. Los efectos se declaran dentro del componente para que tengan acceso a sus accesorios 
y estado. De forma predeterminada, React ejecuta los efectos después de cada renderizado, incluido el primer render.


Los efectos también pueden especificar opcionalmente cómo "limpiar" después de ellos devolviendo una función. 
Por ejemplo, este componente usa un efecto para suscribirse al estado en línea de un amigo y se limpia al 
cancelar la suscripción:

import React, { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return 'Loading...';
  }
  return isOnline ? 'Online' : 'Offline';
}



En este ejemplo, React se daría de baja de nuestro ChatAPIcuando el componente se desmonta, así como 
antes de volver a ejecutar el efecto debido a un renderizado posterior.

Al igual que con useState, puede usar más de un efecto en un componente:

function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() => {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }
  // ...




  Reglas de los Hooks:

Los hooks son funciones de JavaScript, pero imponen dos reglas adicionales:

1.- Solo llame a Hooks en el nivel superior . No llame a Hooks dentro de bucles, condiciones o funciones anidadas.
2.-Solo llame a Hooks desde los componentes de la función React . No llame a Hooks desde funciones regulares 
de JavaScript. (Solo hay otro lugar válido para llamar a Hooks: sus propios Hooks personalizados.




	Resumen Hooks 

//UseState 
Devuelve un valor con estado y una función para actualizarlo.
Util para formularios, poner los valores de referencias con un set 
El operador sprend nos da un copia ...
La función setState se usa para actualizar el estado. Acepta un nuevo valor de estado y 
sitúa en la cola una nueva renderización del componente.

//UseCounter
Para evitar hacerlo con useState, existe useCounter
extrae la logica de mi contador 


//UseEffect
Acepta una función que contiene código imperativo, posiblemente código efectivo.
Ejecutar un efecto cuando ocurra algo en nuestro componente 
Atrapa si algo en especifico esta cambiando 
Conviene poner la funcion en eventos en variables (const) para tener referencia a ella y hacer limpieza
Para un form conviene hacer un customHook con useState y handleInpuText para que lo podamos reutilizar 

//useFetch
Breaking bad API -> https://breakingbadapi.com/
Sirve para hacer conexion a APIs, tiene un state con la info: data, loading, error
El fetch es una promesa que regresa otra promesa fetch(url).then(resp => resp.json()).then(data => {} return state 


//useRef
Es para tener una variables que cambia 
useRef devuelve un objeto ref mutable cuya propiedad .current se inicializa con el 
argumento pasado (initialValue). El objeto devuelto se mantendrá persistente durante 
la vida completa del componente.

//useLayoutEffect
Documentacion --> https://es.reactjs.org/docs/hooks-reference.html#uselayouteffect
La firma es idéntica a useEffect, pero se dispara de forma síncrona después de todas las mutaciones de DOM. 
Use esto para leer el diseño del DOM y volver a renderizar de forma sincrónica. 
Las actualizaciones programadas dentro de useLayoutEffect se vaciarán sincrónicamente, antes de que 
el navegador tenga la oportunidad de pintar.

//memo
Memoriza algo si los props cambian 

//useMemo
Memoriza un resultado para que no se tenga que estar ejecutando 

//¿Qué es un Reducer?
1. Es una función común y corriente
2. Debe de ser una función pura
    No debe de tener efectos secundarios
    No debe de realizar tareas asincronas 
    Debe de retornar siempre un nuevo estado (No debe de mutar)
    No debe de llamar localStorage o SessionStorage 
    No debe de requerir mas que una accion 
3. Debe de retornar un nuevo estado 
4. Usualmente solo recibe dos argumentos(initialState) y la accion a ejecutar 


//Funcionamineto del Reducer
Empieza con un estado inicial = State 
State -> Pagina o Vista -> Accion -> Reducer(Tiene los planos de que puede hacer con el state) 
https://es.reactjs.org/docs/hooks-reference.html#usereducer

Una alternativa a useState. Acepta un reducer de tipo (state, action) => newState y 
devuelve el estado actual emparejado con un método dispatch. (Si está familiarizado con Redux, 
ya sabe cómo funciona).

useReducer a menudo es preferible a useState cuando se tiene una lógica compleja que involucra 
múltiples subvalores o cuando el próximo estado depende del anterior. useReducer además 
te permite optimizar el rendimiento para componentes que activan actualizaciones profundas, 
porque puedes pasar hacia abajo dispatch en lugar de callbacks.


//useContext
Sirve para comunicacion de componentes sin propiedades .








CREANDO TUS PROPIOS Hooks

Un Hook personalizado es una función de JavaScript cuyo nombre comienza con ” use” y que puede llamar a otros Hooks. Por ejemplo, a useFriendStatuscontinuación se muestra nuestro primer Hook personalizado:

import { useState, useEffect } from 'react';

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}


Los Hooks personalizados son una convención que se deriva naturalmente del diseño de Hooks, en 
lugar de una función de React.








MOCKS 

Las funciones simuladas le permiten probar los enlaces entre el código borrando la implementación real 
de una función, capturando llamadas a la función (y los parámetros pasados ​​en esas llamadas), capturando 
instancias de funciones de constructor cuando se crean instancias con newy permitiendo la configuración de 
tiempo de prueba de valores de retorno.

Hay dos formas de simular funciones: ya sea creando una función simulada para usar en el código de prueba o 
escribiendo una manual mockpara anular la dependencia de un módulo.




Using a mock función 

Imaginemos que estamos probando una implementación de una función forEach, que invoca una devolución de 
llamada para cada elemento en una matriz proporcionada.

function forEach(items, callback) {
  for (let index = 0; index < items.length; index++) {
    callback(items[index]);
  }
}

Para probar esta función, podemos usar una función de simulación e inspeccionar el estado de la simulación 
para asegurarnos de que la devolución de llamada se invoque como se esperaba.

const mockCallback = jest.fn(x => 42 + x);
forEach([0, 1], mockCallback);

// The mock function is called twice
expect(mockCallback.mock.calls.length).toBe(2);

// The first argument of the first call to the function was 0
expect(mockCallback.mock.calls[0][0]).toBe(0);

// The first argument of the second call to the function was 1
expect(mockCallback.mock.calls[1][0]).toBe(1);

// The return value of the first call to the function was 42
expect(mockCallback.mock.results[0].value).toBe(42);



.mock property 

Todas las funciones simuladas tienen esta .mockpropiedad especial , que es donde se guardan los datos sobre 
cómo se ha llamado a la función y qué función devuelve. La .mockpropiedad también rastrea el valor de this 
para cada llamada, por lo que también es posible inspeccionar esto:

const myMock = jest.fn();

const a = new myMock();
const b = {};
const bound = myMock.bind(b);
bound();

console.log(myMock.mock.instances);
// > [ <a>, <b> ]


Estos miembros simulados son muy útiles en las pruebas para afirmar cómo se llaman, 
instancian o qué devuelven estas funciones:

// The function was called exactly once
expect(someMockFunction.mock.calls.length).toBe(1);

// The first arg of the first call to the function was 'first arg'
expect(someMockFunction.mock.calls[0][0]).toBe('first arg');

// The second arg of the first call to the function was 'second arg'
expect(someMockFunction.mock.calls[0][1]).toBe('second arg');

// The return value of the first call to the function was 'return value'
expect(someMockFunction.mock.results[0].value).toBe('return value');

// This function was instantiated exactly twice
expect(someMockFunction.mock.instances.length).toBe(2);

// The object returned by the first instantiation of this function
// had a `name` property whose value was set to 'test'
expect(someMockFunction.mock.instances[0].name).toEqual('test');


Valores de retornos simulados 

Las funciones simuladas también se pueden usar para inyectar valores de prueba en su código durante una prueba:

const myMock = jest.fn();
console.log(myMock());
// > undefined

myMock.mockReturnValueOnce(10).mockReturnValueOnce('x').mockReturnValue(true);

console.log(myMock(), myMock(), myMock(), myMock());
// > 10, 'x', true, true

Las funciones simuladas también son muy efectivas en el código que usa un estilo funcional de paso de 
continuación. El código escrito en este estilo ayuda a evitar la necesidad de códigos auxiliares complicados 
que recrean el comportamiento del componente real que representan, a favor de inyectar valores directamente en la 
prueba justo antes de su uso.


const filterTestFn = jest.fn();

// Make the mock return `true` for the first call,
// and `false` for the second call
filterTestFn.mockReturnValueOnce(true).mockReturnValueOnce(false);

const result = [11, 12].filter(num => filterTestFn(num));

console.log(result);
// > [11]
console.log(filterTestFn.mock.calls[0][0]); // 11
console.log(filterTestFn.mock.calls[1][0]); // 12

La mayoría de los ejemplos del mundo real en realidad implican obtener una función simulada en un 
componente dependiente y configurarla, pero la técnica es la misma. En estos casos, intente evitar la 
tentación de implementar lógica dentro de cualquier función que no se esté probando directamente.


Mocking Modules 

Supongamos que tenemos una clase que busca usuarios de nuestra API. La clase usa axios para llamar a la 
API y luego devuelve el data atributo que contiene a todos los usuarios:

// users.js
import axios from 'axios';

class Users {
  static all() {
    return axios.get('/users.json').then(resp => resp.data);
  }
}

export default Users;


Ahora, para probar este método sin llegar a la API (y así crear pruebas lentas y frágiles), podemos usar 
la jest.mock(...)función para simular automáticamente el módulo axios.

Una vez que simulamos el módulo, podemos proporcionar un mockResolvedValuepara .getque devuelva los datos 
que queremos que nuestra prueba confirme. En efecto, estamos diciendo que queremos axios.get('/users.json')
devolver una respuesta falsa.


// users.test.js
import axios from 'axios';
import Users from './users';

jest.mock('axios');

test('should fetch users', () => {
  const users = [{name: 'Bob'}];
  const resp = {data: users};
  axios.get.mockResolvedValue(resp);

  // or you could use the following depending on your use case:
  // axios.get.mockImplementation(() => Promise.resolve(resp))

  return Users.all().then(data => expect(data).toEqual(users));
});


Mock implementation 

Aún así, hay casos en los que es útil ir más allá de la capacidad de especificar valores de retorno y 
reemplazar por completo la implementación de una función simulada. Esto se puede hacer con jest.fnel 
mockImplementationOncemétodo o en funciones simuladas.

const myMockFn = jest.fn(cb => cb(null, true));

myMockFn((err, val) => console.log(val));
// > true

El mockImplementationmétodo es útil cuando necesita definir la implementación predeterminada de una función 
simulada que se crea a partir de otro módulo:

// foo.js
module.exports = function () {
  // some implementation;
};

// test.js
jest.mock('../foo'); // this happens automatically with automocking
const foo = require('../foo');

// foo is a mock function
foo.mockImplementation(() => 42);
foo();
// > 42

Cuando necesite recrear un comportamiento complejo de una función simulada de manera que múltiples 
llamadas a funciones produzcan resultados diferentes, use el mockImplementationOncemétodo:

const myMockFn = jest
  .fn()
  .mockImplementationOnce(cb => cb(null, true))
  .mockImplementationOnce(cb => cb(null, false));

myMockFn((err, val) => console.log(val));
// > true

myMockFn((err, val) => console.log(val));
// > false

Cuando la función simulada se queda sin implementaciones definidas con mockImplementationOnce, 
ejecutará la implementación predeterminada establecida con jest.fn(si está definida):

const myMockFn = jest
  .fn(() => 'default')
  .mockImplementationOnce(() => 'first call')
  .mockImplementationOnce(() => 'second call');

console.log(myMockFn(), myMockFn(), myMockFn(), myMockFn());
// > 'first call', 'second call', 'default', 'default'

Para los casos en los que tenemos métodos que normalmente están encadenados (y, por lo tanto, siempre deben 
regresar this), tenemos una API dulce para simplificar esto en forma de una .mockReturnThis()función que 
también se encuentra en todos los simulacros:

const myObj = {
  myMethod: jest.fn().mockReturnThis(),
};

// is the same as

const otherObj = {
  myMethod: jest.fn(function () {
    return this;
  }),
};


Coincidentes personalizados 

Finalmente, para que sea menos exigente afirmar cómo se han llamado las funciones simuladas, 
hemos agregado algunas funciones de comparador personalizadas para usted:

// The mock function was called at least once
expect(mockFunc).toHaveBeenCalled();

// The mock function was called at least once with the specified args
expect(mockFunc).toHaveBeenCalledWith(arg1, arg2);

// The last call to the mock function was called with the specified args
expect(mockFunc).toHaveBeenLastCalledWith(arg1, arg2);

// All calls and the name of the mock is written as a snapshot
expect(mockFunc).toMatchSnapshot();

Estos emparejadores son azúcar para formas comunes de inspeccionar la .mockpropiedad. Siempre puede 
hacer esto manualmente usted mismo si eso es más de su gusto o si necesita hacer algo más específico:

// The mock function was called at least once
expect(mockFunc.mock.calls.length).toBeGreaterThan(0);

// The mock function was called at least once with the specified args
expect(mockFunc.mock.calls).toContainEqual([arg1, arg2]);

// The last call to the mock function was called with the specified args
expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1]).toEqual([
  arg1,
  arg2,
]);

// The first arg of the last call to the mock function was `42`
// (note that there is no sugar helper for this specific of an assertion)
expect(mockFunc.mock.calls[mockFunc.mock.calls.length - 1][0]).toBe(42);

// A snapshot will check that a mock was invoked the same number of times,
// in the same order, with the same arguments. It will also assert on the name.
expect(mockFunc.mock.calls).toEqual([[arg1, arg2]]);
expect(mockFunc.getMockName()).toBe('a mock name');








Firing Events

Nota: La mayoría de los proyectos tienen algunos casos de uso fireEvent, pero la mayoría de las veces 
probablemente debería usar @testing-library/user-event.

fireEvent(node: HTMLElement, event: Event)

Eventos DOM de fire 

// <button>Submit</button>
fireEvent(
  getByText(container, 'Submit'),
  new MouseEvent('click', {
    bubbles: true,
    cancelable: true,
  }),
)


fireEvent[eventName]

fireEvent[eventName](node: HTMLElement, eventProperties: Object)

Métodos de conveniencia para disparar eventos DOM. Consulte src / event-map.js para obtener una lista 
completa y la predeterminada eventProperties.

target : cuando un evento se distribuye en un elemento, el evento tiene el elemento sujeto en una propiedad 
llamada target. Para su comodidad, si proporciona una targetpropiedad en el eventProperties(segundo argumento), 
esas propiedades se asignarán al nodo que recibe el evento.

Esto es particularmente útil para un evento de cambio:

fireEvent.change(getByLabelText(/username/i), {target: {value: 'a'}})

// note: attempting to manually set the files property of an HTMLInputElement
// results in an error as the files property is read-only.
// this feature works around that by using Object.defineProperty.
fireEvent.change(getByLabelText(/picture/i), {
  target: {
    files: [new File(['(⌐□_□)'], 'chucknorris.png', {type: 'image/png'})],
  },
})

// Note: The 'value' attribute must use ISO 8601 format when firing a
// change event on an input of type "date". Otherwise the element will not
// reflect the changed value.

// Invalid:
fireEvent.change(input, {target: {value: '24/05/2020'}})

// Valid:
fireEvent.change(input, {target: {value: '2020-05-24'}})


dataTransfer : los eventos de arrastre tienen una dataTransferpropiedad que contiene los datos 
transferidos durante la operación. Para su comodidad, si proporciona una dataTransferpropiedad en el 
eventProperties(segundo argumento), esas propiedades se agregarán al evento.

Esto debe usarse principalmente para probar las interacciones de arrastrar y soltar.

fireEvent.drop(getByLabelText(/drop files here/i), {
  dataTransfer: {
    files: [new File(['(⌐□_□)'], 'chucknorris.png', {type: 'image/png'})],
  },
})



Los eventos de teclado : Hay tres tipos de eventos relacionados con la entrada de
 teclado - keyPress, keyDowny keyUp. Al disparar estos, debe hacer referencia a un elemento en el DOM y la 
 clave que desea disparar.

fireEvent.keyDown(domNode, {key: 'Enter', code: 'Enter'})

fireEvent.keyDown(domNode, {key: 'A', code: 'KeyA'})


createEvent[eventName]

createEvent[eventName](node: HTMLElement, eventProperties: Object)

Métodos de conveniencia para crear eventos DOM que luego se pueden activar fireEvent, lo que le permite 
tener una referencia al evento creado: esto podría ser útil si necesita acceder a propiedades de eventos que 
no se pueden iniciar mediante programación (como timeStamp).


const myEvent = createEvent.click(node, {button: 2})
fireEvent(node, myEvent)
// myEvent.timeStamp can be accessed just like any other properties from myEvent
// note: The access to the events created by `createEvent` is based on the native event API,
// Therefore, native properties of HTMLEvent object (e.g. `timeStamp`, `cancelable`, `type`) should be set using Object.defineProperty
// For more info see: https://developer.mozilla.org/en-US/docs/Web/API/Event

También puede crear eventos genéricos:

// simulate the 'input' event on a file input
fireEvent(
  input,
  createEvent('input', input, {
    target: {files: inputFiles},
    ...init,
  }),
)


Using Jest function mocks 

Las funciones Mock de Jest se pueden usar para probar que se llamó a una devolución de llamada pasada a la 
función, o cómo se llamó cuando el evento que debería activar la función de devolución de llamada activa la 
devolución de llamada enlazada.

import {render, screen, fireEvent} from '@testing-library/react'

const Button = ({onClick, children}) => (
  <button onClick={onClick}>{children}</button>
)

test('calls onClick prop when clicked', () => {
  const handleClick = jest.fn()
  render(<Button onClick={handleClick}>Click Me</Button>)
  fireEvent.click(screen.getByText(/click me/i))
  expect(handleClick).toHaveBeenCalledTimes(1)
})




******************************************************************************

					Local state 

Class component 
-Declare state in the constructor
-Uses this.setState(...args) to update state 

Functional component
-Declare and update state using the useSate hook 



			Prop Drilling 

Prop Drilling is the process to get data to parts of the React Components Tree 
passing teh data ad props to child components 



			Context 

El contexto proporciona una forma de pasar datos a través del árbol de componentes sin tener que 
pasar los accesorios manualmente en todos los niveles.


En una aplicación típica de React, los datos se transmiten de arriba hacia abajo (de padre a hijo) a 
través de accesorios, pero dicho uso puede ser engorroso para ciertos tipos de accesorios (por ejemplo, 
preferencia de configuración regional, tema de interfaz de usuario) que son necesarios para muchos 
componentes dentro de una aplicación. El contexto proporciona una forma de compartir valores como estos 
entre componentes sin tener que pasar explícitamente un accesorio a través de cada nivel del árbol.


Ejemplo Theme : https://reactjs.org/docs/context.html

El contexto está diseñado para compartir datos que pueden considerarse "globales" para un árbol de 
componentes de React, como el usuario autenticado actual, el tema o el idioma preferido. Por ejemplo, 
en el código a continuación, pasamos manualmente a través de un accesorio de "tema" para diseñar el 
componente Botón:

class App extends React.Component {
  render() {
    return <Toolbar theme="dark" />;
  }
}

function Toolbar(props) {
  // The Toolbar component must take an extra "theme" prop
  // and pass it to the ThemedButton. This can become painful
  // if every single button in the app needs to know the theme
  // because it would have to be passed through all components.
  return (
    <div>
      <ThemedButton theme={props.theme} />
    </div>
  );
}

class ThemedButton extends React.Component {
  render() {
    return <Button theme={this.props.theme} />;
  }
}

Usando el contexto, podemos evitar pasar accesorios a través de elementos intermedios:

// Context lets us pass a value deep into the component tree
// without explicitly threading it through every component.
// Create a context for the current theme (with "light" as the default).
const ThemeContext = React.createContext('light');

class App extends React.Component {
  render() {
    // Use a Provider to pass the current theme to the tree below.
    // Any component can read it, no matter how deep it is.
    // In this example, we're passing "dark" as the current value.
    return (
      <ThemeContext.Provider value="dark">
        <Toolbar />
      </ThemeContext.Provider>
    );
  }
}

// A component in the middle doesn't have to
// pass the theme down explicitly anymore.
function Toolbar() {
  return (
    <div>
      <ThemedButton />
    </div>
  );
}

class ThemedButton extends React.Component {
  // Assign a contextType to read the current theme context.
  // React will find the closest theme Provider above and use its value.
  // In this example, the current theme is "dark".
  static contextType = ThemeContext;
  render() {
    return <Button theme={this.context} />;
  }
}




Si solo desea evitar pasar algunos accesorios a través de muchos niveles, la composición de 
componentes es a menudo una solución más simple que el contexto.

Por ejemplo, considere un Pagecomponente que pasa una usery avatarSizeprop varios niveles hacia abajo 
para que profundamente anidados Linky Avatarcomponentes pueden leerla:

<Page user={user} avatarSize={avatarSize} />
// ... which renders ...
<PageLayout user={user} avatarSize={avatarSize} />
// ... which renders ...
<NavigationBar user={user} avatarSize={avatarSize} />
// ... which renders ...
<Link href={user.permalink}>
  <Avatar user={user} size={avatarSize} />
</Link>


Puede parecer redundante pasar los accesorios usery a avatarSizetravés de muchos niveles si al final solo 
el Avatarcomponente realmente lo necesita. También es molesto que cada vez que el Avatar componente necesite 
más accesorios de la parte superior, también tenga que agregarlos en todos los niveles intermedios.

Una forma de resolver este problema sin contexto es transmitir el Avatarcomponente en sí para que los componentes 
intermedios no necesiten saber sobre los accesorios usero avatarSize:

function Page(props) {
  const user = props.user;
  const userLink = (
    <Link href={user.permalink}>
      <Avatar user={user} size={props.avatarSize} />
    </Link>
  );
  return <PageLayout userLink={userLink} />;
}

// Now, we have:
<Page user={user} avatarSize={avatarSize} />
// ... which renders ...
<PageLayout userLink={...} />
// ... which renders ...
<NavigationBar userLink={...} />
// ... which renders ...
{props.userLink}

Con este cambio, sólo los más altos en las necesidades de componentes Página saber sobre el Linky 
Avata uso de componentes usery avatarSize.





			API 
		React.createContext 

const MyContext = React.createContext(defaultValue);

Crea un objeto de contexto. Cuando React renderiza un componente que se suscribe a este objeto Context, 
leerá el valor de contexto actual de la coincidencia más cercana Providersobre él en el árbol.

El defaultValueargumento solo se usa cuando un componente no tiene un Proveedor coincidente encima en el árbol. 
Este valor predeterminado puede ser útil para probar componentes de forma aislada sin envolverlos. Nota: pasar 
undefinedcomo un valor de proveedor no hace que se utilicen componentes consumidores defaultValue.


Context.Provider 

<MyContext.Provider value={/* some value */}>

Cada objeto Context viene con un componente Provider React que permite que los componentes consumidores se 
suscriban a los cambios de contexto.

El componente Proveedor acepta una valuepropiedad para pasar a los componentes consumidores que son descendientes 
de este Proveedor. Un proveedor puede conectarse con muchos consumidores. Los proveedores se pueden anidar para 
anular valores más profundos dentro del árbol.

Todos los consumidores que son descendientes de un proveedor volverán a renderizarse cada vez que valuecambie la 
propiedad del proveedor . La propagación del proveedor a sus consumidores descendientes (incluidos .contextTypey 
useContext) no está sujeta al shouldComponentUpdatemétodo, por lo que el consumidor se actualiza incluso cuando 
un componente antecesor omite una actualización.

Los cambios se determinan comparando los valores nuevos y antiguos utilizando el mismo algoritmo que Object.is.



	Context API 

Provider: The provider wraps our presentational component and stores data in its state  
Consumer: The consumer is a descendant of the presentational component and allowa us to grab values from the provider

function App() {
  const [currentEmployee, setCurrentEmployee] = useState(employees[0]);
  const [filter, setFilter] = useState("");

  return (
    <div className="App">
      <EmployeeContext.Provider
        value={{
          currentEmployee,
          employees,
          setCurrentEmployee,
          filter,
          setFilter
        }}
      >
        <HomePage />
        <EmployeePage />
      </EmployeeContext.Provider>
    </div>
  );
}

Buena explicación de Context con functional components con useReducer y useContext:
https://hswolff.com/blog/how-to-usecontext-with-usereducer/


			Window.localStorage 

La localStoragepropiedad de sólo lectura de la windowinterfaz le permite acceder a un Storageobjeto 
para el Document's de origen ; los datos almacenados se guardan en todas las sesiones del navegador.


	Sintaxis 

myStorage = window.localStorage;

Valor -> Un Storageobjeto que se puede utilizar para acceder al espacio de almacenamiento local del origen actual.


	Descripcion:

Las claves y los valores almacenados con siemprelocalStorage están en formato UTF-16 , que utiliza 
dos bytes por carácter. Al igual que con los objetos, las claves de números enteros se convierten 
automáticamente en cadenas.DOMString

localStorageLos datos son específicos del protocolo del documento . En particular, para un sitio cargado a 
través de HTTP (p. Ej., http://example.com), localStorageDevuelve un objeto diferente al localStoragedel 
sitio correspondiente cargado a través de HTTPS (p https://example.com. Ej., ).

Para documentos cargados desde file:URL (es decir, archivos abiertos en el navegador directamente desde el 
sistema de archivos local del usuario, en lugar de ser servidos desde un servidor web), los requisitos de 
localStoragecomportamiento no están definidos y pueden variar entre diferentes navegadores.

En todos los navegadores actuales, localStorageparece devolver un objeto diferente para cada file:URL. En 
otras palabras, cada file:URL parece tener su propia área de almacenamiento local única. Pero no hay garantías 
sobre ese comportamiento, por lo que no debe confiar en él porque, como se mencionó anteriormente, los 
requisitos para las file:URL siguen sin estar definidos. Por lo tanto, es posible que los navegadores 
cambien su file:manejo de URL localStorageen cualquier momento. De hecho, algunos navegadores han cambiado 
su manejo con el tiempo.

Ejemplo:

El siguiente fragmento accede al Storage objeto local del dominio actual y le agrega un elemento de 
datos usando Storage.setItem().

	localStorage.setItem('myCat', 'Tom');

La sintaxis para leer el localStorageartículo es la siguiente:

	const cat = localStorage.getItem('myCat');

La sintaxis para eliminar el localStorageelemento es la siguiente:

	localStorage.removeItem('myCat');

La sintaxis para eliminar todos los localStorageelementos es la siguiente:

	localStorage.clear();







			Window.sessionStorage 

La sessionStorage propiedad de solo lectura accede a un Storageobjeto de sesión para el origen actual 
.sessionStoragees similar a localStorage; la diferencia es que, si bien los datos localStorage ingresados ​​
no caducan, los datos sessionStorageingresados ​​se borran cuando finaliza la sesión de la página .

Siempre que se carga un documento en una pestaña en particular del navegador, se crea una sesión de página 
única y se asigna a esa pestaña en particular. Esa sesión de página es válida solo para esa pestaña en particular.
Una sesión de página dura mientras la pestaña o el navegador estén abiertos y sobrevive después de que la 
página se recargue y se restaure.
Abrir una página en una nueva pestaña o ventana crea una nueva sesión con el valor del contexto de navegación 
de nivel superior, que difiere de cómo funcionan las cookies de sesión.
La apertura de varias pestañas / ventanas con la misma URL crea sessionStorage para cada pestaña / ventana.
Duplicar una pestaña copia las pestañas sessionStorageen la nueva pestaña.
Cerrar una pestaña / ventana finaliza la sesión y borra los objetos sessionStorage.

Los datos almacenados sessionStorage son específicos del protocolo de la página . En particular, los 
datos almacenados por un script en un sitio al que se accede con HTTP se coloca en un sessionStorage 
objeto diferente del mismo sitio al que se accede con HTTPS 

Las claves y los valores siempre están en DOMString formato UTF-16 , que utiliza dos bytes por carácter. 
Al igual que con los objetos, las claves de números enteros se convierten automáticamente en cadenas.


Sintaxis 

	myStorage = window.sessionStorage;

Valor:

Un Storageobjeto que se puede utilizar para acceder al espacio de almacenamiento de la sesión del origen actual.


Ejemplo de uso basico 

// Save data to sessionStorage
sessionStorage.setItem('key', 'value');

// Get saved data from sessionStorage
let data = sessionStorage.getItem('key');

// Remove saved data from sessionStorage
sessionStorage.removeItem('key');

// Remove all saved data from sessionStorage
sessionStorage.clear();



Guardar texto entre actualizaciones 

El siguiente ejemplo guarda automáticamente el contenido de un campo de texto y, si se actualiza el 
navegador, restaura el contenido del campo de texto para que no se pierda la escritura.

// Get the text field that we're going to track
let field = document.getElementById("field");

// See if we have an autosave value
// (this will only happen if the page is accidentally refreshed)
if (sessionStorage.getItem("autosave")) {
  // Restore the contents of the text field
  field.value = sessionStorage.getItem("autosave");
}

// Listen for changes in the text field
field.addEventListener("change", function() {
  // And save the results into the session storage object
  sessionStorage.setItem("autosave", field.value);
});








					Pruebas de useReducer:
https://testing-library.com/docs/example-react-hooks-usereducer/

Ejemplo básico que muestra cómo probar el useReducergancho. Lo más importante es que no estamos probando 
el reductor directamente, ¡es un detalle de implementación del componente! En su lugar, estamos probando 
la interfaz del componente.

El componente que estamos probando cambia algo de texto dependiendo de un isConfirmed estado.

// example.js

import React, {useReducer} from 'react'

const initialState = {
  isConfirmed: false,
}

function reducer(state = initialState, action) {
  switch (action.type) {
    case 'SUCCESS':
      return {
        ...state,
        isConfirmed: true,
      }
    default:
      throw Error('unknown action')
  }
}

const Example = () => {
  const [state, dispatch] = useReducer(reducer, initialState)

  return (
    <div>
      <div>
        {state.isConfirmed ? (
          <p>Confirmed!</p>
        ) : (
          <p>Waiting for confirmation...</p>
        )}
      </div>
      <button onClick={() => dispatch({type: 'SUCCESS'})}>Confirm</button>
    </div>
  )
}

export default Example

Estamos probando para ver si obtenemos la salida correcta en nuestro JSX según el estado del reductor.

// example.test.js

import React from 'react'
import {render, fireEvent} from '@testing-library/react'
import Example from './example.js'

it('shows success message after confirm button is clicked', () => {
  const {getByText} = render(<Example />)

  expect(getByText(/waiting/i)).toBeInTheDocument()

  fireEvent.click(getByText('Confirm'))

  expect(getByText('Confirmed!')).toBeInTheDocument()
})




******************************************************************************


		useReducer

const [state, dispatch] = useReducer(reducer, initialArg, init);

Reducer flow: State -> Page -> Action -> Reducer -> State 





******************************************************************************

		Presentational and Container Componets 


Descubrirá que sus componentes son mucho más fáciles de reutilizar y razonar si los divide en dos 
categorías. Los llamo Contenedores y Componentes de presentación * pero también escuché Fat and Skinny , 
Smart and Dumb, Stateful and Pure , Screens and Components , etc. No todos son exactamente iguales, pero la 
idea central es similar.

Mis presentational componets::

Les preocupa cómo se ven las cosas .
Puede contener componentes de presentación y contenedor ** en su interior y, por lo general, tienen algunos estilos y marcas DOM propios.
A menudo permite la contención a través de this.props.children .
No dependa del resto de la aplicación, como acciones o tiendas de Flux.
No especifique cómo se cargan o se modifican los datos.
Reciba datos y devoluciones de llamada exclusivamente a través de accesorios.
Rara vez tienen su propio estado (cuando lo tienen, es el estado de la interfaz de usuario en lugar de los datos).
Están escritos como componentes funcionales a menos que necesiten estados, enlaces de ciclo de vida u optimizaciones de rendimiento.

--> Ejemplos: página, barra lateral, historia, información de usuario, lista.

Mis container componets:

Están preocupados por cómo funcionan las cosas .
Puede contener componentes de presentación y contenedor ** en su interior, pero por lo general no tienen ningún marcado DOM propio, excepto algunos divs de envoltura, y nunca tienen estilos.
Proporcione los datos y el comportamiento a los componentes de presentación u otros componentes del contenedor.
Llame a las acciones de Flux y proporciónelas como devoluciones de llamada a los componentes de presentación.
A menudo tienen estado, ya que tienden a servir como fuentes de datos.
Por lo general, se generan utilizando componentes de orden superior , como connect () de React Redux, createContainer () de Relay o Container.create () de Flux Utils, en lugar de escribirlos a mano.

--> Ejemplos: UserPage, FollowersSidebar, StoryContainer, FollowedUserList.

Beneficios de este enfoque:

Mejor separación de preocupaciones. Comprende mejor su aplicación y su interfaz de usuario escribiendo componentes de esta manera.
Mejor reutilización. Puede usar el mismo componente de presentación con fuentes de estado completamente diferentes y convertirlas en componentes de contenedor separados que se pueden reutilizar.
Los componentes de presentación son esencialmente la "paleta" de su aplicación. Puede ponerlos en una sola página y dejar que el diseñador modifique todas sus variaciones sin tocar la lógica de la aplicación. Puede ejecutar pruebas de regresión de captura de pantalla en esa página.
Esto le obliga a extraer "componentes de diseño" como Sidebar, Page, ContextMenu y utilizar this.props.children en lugar de duplicar el mismo marcado y diseño en varios componentes del contenedor.


NOTA: 

Recordar, los componentes no tienen que emitir DOM. Solo necesitan proporcionar límites de composición entre 
las preocupaciones de la interfaz de usuario.



¿Cuándo introducir contenedores?
Le sugiero que comience a construir su aplicación con solo componentes de presentación primero. Con el tiempo,
 se dará cuenta de que está pasando demasiados accesorios por los componentes intermedios. Cuando observe que 
 algunos componentes no usan los accesorios que reciben, sino que simplemente los reenvían y tiene que volver 
 a cablear todos esos componentes intermedios cada vez que los niños necesitan más datos, es un buen momento para 
 introducir algunos componentes del contenedor. De esta manera, puede obtener los datos y los accesorios de 
 comportamiento para los componentes de la hoja sin sobrecargar los componentes no relacionados 
 en el medio del árbol.

Este es un proceso continuo de refactorización, así que no intente hacerlo bien la primera vez. 
A medida que experimente con este patrón, desarrollará un sentido intuitivo de cuándo es el momento de 
extraer algunos contenedores, al igual que sabe cuándo es el momento de extraer una función.






Los componentes inteligentes son componentes de nivel de aplicación que realizan funciones y administran datos, 
mientras que los componentes tontos se enfocan únicamente en la interfaz de usuario.

Las características comunes de los componentes inteligentes incluyen:

Manipula datos Los componentes inteligentes pueden buscar, capturar cambios y transmitir datos de aplicaciones.
Llame a Redux, métodos de ciclo de vida, API, bibliotecas, etc.¡Estos componentes se llaman inteligentes por una razón! Son responsables de llamar a las bibliotecas y la funcionalidad.
Administrar estado Los componentes inteligentes son responsables de administrar el estado y saber cuándo volver a renderizar un componente.
Rara vez incluye estilo Dado que los componentes tontos se centran en el estilo, permite que el componente inteligente se centre en la funcionalidad sin el desorden de estilos también.


Características comunes de los componentes tontos:

Centrarse en la interfaz de usuarioCasi todos los componentes básicos de la interfaz de usuario deben considerarse componentes tontos. Los ejemplos incluyen cargadores, modales, botones, entradas, etc.
Aceptar accesoriosLos componentes tontos aceptan accesorios para permitirles ser dinámicos y reutilizables. Por ejemplo, puede enviar el título de un botón en accesorios del componente principal para permitirle tener un nombre único.
No requiere dependencias de aplicacionesAparte de los paquetes de IU, como los Reactstrapcomponentes tontos, no requieren dependencias.
Rara vez incluyen el estadoLa única instancia en la que un componente tonto tiene estado es para manipular la propia interfaz de usuario, no los datos de la aplicación. Algunos ejemplos de dónde podría tener estado un componente tonto serían los grupos de botones, pestañas, interruptores y otros elementos de la interfaz de usuario que no afectan los datos, solo la interfaz de usuario.

Beneficios:
-reutilización
-Flexibilidad para realizar cambios facilmente
-Legibilidad de código 
-Proporciona coherencia y evita la duplicación
-Simplifica las decisiones de la interfaz de usuario 
-Facil de probar 



******************************************************************************

		Composition vs inheritance

React tiene un modelo de composición poderoso, y recomendamos usar la composición en lugar de la 
herencia para reutilizar el código entre componentes.


Containment:

Algunos componentes no conocen a sus hijos de antemano. Esto es especialmente común para componentes como 
Sidebaro Dialogque representan "cajas" genéricas.

Recomendamos que dichos componentes utilicen el childrenaccesorio especial para pasar elementos secundarios 
directamente a su salida:

function FancyBorder(props) {
  return (
    <div className={'FancyBorder FancyBorder-' + props.color}>
      {props.children}
    </div>
  );
}


Esto permite que otros componentes les pasen hijos arbitrarios anidando el JSX:

function WelcomeDialog() {
  return (
    <FancyBorder color="blue">
      <h1 className="Dialog-title">
        Welcome
      </h1>
      <p className="Dialog-message">
        Thank you for visiting our spacecraft!
      </p>
    </FancyBorder>
  );
}

Todo lo que <FancyBorder>esté dentro de la etiqueta JSX se pasa al FancyBordercomponente 
como un childrenaccesorio. Dado que se FancyBorderrenderiza {props.children}dentro de a <div>, 
los elementos pasados ​​aparecen en la salida final.

Si bien esto es menos común, a veces es posible que necesite varios "agujeros" en un componente. En tales casos, 
puede crear su propia convención en lugar de usar children:

function SplitPane(props) {
  return (
    <div className="SplitPane">
      <div className="SplitPane-left">
        {props.left}
      </div>
      <div className="SplitPane-right">
        {props.right}
      </div>
    </div>
  );
}

function App() {
  return (
    <SplitPane
      left={
        <Contacts />
      }
      right={
        <Chat />
      } />
  );
}

Los elementos reaccionan como <Contacts />y <Chat />son solo objetos, por lo que puede pasarlos como 
ccesorios como cualquier otro dato. Este enfoque puede recordarle las "ranuras" en otras bibliotecas, 
pero no hay limitaciones sobre lo que puede pasar como accesorios en React.




Especializacion:

A veces pensamos en los componentes como "casos especiales" de otros componentes. Por ejemplo, podríamos 
decir que a WelcomeDialoges un caso especial de Dialog.

En React, esto también se logra mediante la composición, donde un componente más "específico" representa uno 
más "genérico" y lo configura con accesorios:

function Dialog(props) {
  return (
    <FancyBorder color="blue">
      <h1 className="Dialog-title">
        {props.title}
      </h1>
      <p className="Dialog-message">
        {props.message}
      </p>
    </FancyBorder>
  );
}

function WelcomeDialog() {
  return (
    <Dialog
      title="Welcome"
      message="Thank you for visiting our spacecraft!" />
  );
}

La composición funciona igualmente bien para componentes definidos como clases:

function Dialog(props) {
  return (
    <FancyBorder color="blue">
      <h1 className="Dialog-title">
        {props.title}
      </h1>
      <p className="Dialog-message">
        {props.message}
      </p>
      {props.children}
    </FancyBorder>
  );
}

class SignUpDialog extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
    this.handleSignUp = this.handleSignUp.bind(this);
    this.state = {login: ''};
  }

  render() {
    return (
      <Dialog title="Mars Exploration Program"
              message="How should we refer to you?">
        <input value={this.state.login}
               onChange={this.handleChange} />
        <button onClick={this.handleSignUp}>
          Sign Me Up!
        </button>
      </Dialog>
    );
  }

  handleChange(e) {
    this.setState({login: e.target.value});
  }

  handleSignUp() {
    alert(`Welcome aboard, ${this.state.login}!`);
  }
}


¿Que pasá con le herencia?

En Facebook, usamos React en miles de componentes y no hemos encontrado ningún caso de uso en el que 
recomendaríamos crear jerarquías de herencia de componentes.

Los accesorios y la composición le brindan toda la flexibilidad que necesita para personalizar el aspecto y el 
comportamiento de un componente de una manera explícita y segura. Recuerde que los componentes pueden aceptar 
accesorios arbitrarios, incluidos valores primitivos, elementos React o funciones.

Si desea reutilizar la funcionalidad que no es de la interfaz de usuario entre componentes, le sugerimos que la 
extraiga en un módulo de JavaScript separado. Los componentes pueden importarlo y usar esa función, objeto o clase,
sin extenderlo.




function swimmer({name}){
	return {
		swim: () => clg(`${name} swam`)
	}
}
function swimmer({name}){
	return {
		swim: () => clg(`${name} flew`)
	}
}





function swimmingMosterCreator(name){
	const monster = {name:name}

	return {
		...monster,
		...swimmer(monster)
	}
}

function flyingswimmingMosterCreator(name){
	const monster = {name:name}

	return {
		...monster,
		...swimmer(monster)
		...flyer(monster)
	}
}


const obj = flyingswimmingMosterCreator('Monster')
obj.swim();
obj.fly();

Explicación: https://www.youtube.com/watch?v=nnwD5Lwwqdo


******************************************************************************

		Lifting State up

A menudo, varios componentes deben reflejar los mismos datos cambiantes. Recomendamos elevar el estado 
compartido a su antepasado común más cercano. Veamos cómo funciona esto en acción.

Debe haber una única "fuente de verdad" para cualquier dato que cambie en una aplicación React. Por lo general, 
el estado se agrega primero al componente que lo necesita para renderizar. Luego, si otros componentes también 
lo necesitan, puede elevarlo a su ancestro común más cercano. En lugar de intentar sincronizar el estado entre 
diferentes componentes, debe confiar en el flujo de datos de arriba hacia abajo .

El estado de elevación implica escribir más código "repetitivo" que los enfoques de enlace bidireccional, pero 
como beneficio, se necesita menos trabajo para encontrar y aislar errores. Dado que cualquier estado "vive" en 
algún componente y ese componente solo puede cambiarlo, el área de superficie para los errores se reduce 
considerablemente. Además, puede implementar cualquier lógica personalizada para rechazar o transformar la entrada del usuario.

Si algo se puede derivar de los accesorios o del estado, probablemente no debería estar en el estado. 
Por ejemplo, en lugar de almacenar ambos celsiusValuey fahrenheitValue, almacenamos solo la última edición 
temperaturey su scale. El valor de la otra entrada siempre se puede calcular a partir de ellos en el 
render()método. Esto nos permite borrar o aplicar redondeo al otro campo sin perder precisión en la entrada 
del usuario.

Cuando vea algo mal en la interfaz de usuario, puede usar React Developer Tools para inspeccionar los 
accesorios y moverse hacia arriba en el árbol hasta que encuentre el componente responsable de actualizar el estado.

Explicacion con functional componets: https://www.youtube.com/watch?v=HF4o9KAZNxw


******************************************************************************

		Atomic Design

Excelente explicación: https://www.youtube.com/watch?v=Yi-A20x2dcA

En la búsqueda de inspiración y paralelismos, seguí volviendo a la química. La idea es que toda la 
materia (ya sea sólida, líquida, gaseosa, simple, compleja, etc.) está compuesta de átomos. Esas unidades 
atómicas se unen para formar moléculas, que a su vez se combinan en organismos más complejos para finalmente 
crear toda la materia en nuestro universo.

Del mismo modo, las interfaces están formadas por componentes más pequeños. Esto significa que podemos dividir 
interfaces enteras en bloques de construcción fundamentales y trabajar desde allí. Esa es la esencia básica 
del diseño atómico.

¿qué es el diseño atómico?
El diseño atómico es una metodología para crear sistemas de diseño. 
Hay cinco niveles distintos en el diseño atómico:

	1.-Átomos

Los átomos son los componentes básicos de la materia. Aplicados a las interfaces web, los átomos son 
nuestras etiquetas HTML, como una etiqueta de formulario, una entrada o un botón.

Los átomos también pueden incluir elementos más abstractos como paletas de colores, fuentes e incluso aspectos 
más invisibles de una interfaz como animaciones.

Al igual que los átomos en la naturaleza, son bastante abstractos y, a menudo, no son muy útiles por sí mismos. 
Sin embargo, son buenos como referencia en el contexto de una biblioteca de patrones, ya que puede ver todos 
sus estilos globales presentados de un vistazo.


	2.-Moléculas

Las cosas comienzan a ponerse más interesantes y tangibles cuando comenzamos a combinar átomos. Las moléculas 
son grupos de átomos unidos entre sí y son las unidades fundamentales más pequeñas de un compuesto. Estas 
moléculas adquieren sus propias propiedades y sirven como columna vertebral de nuestros sistemas de diseño.

Por ejemplo, una etiqueta de formulario, una entrada o un botón no son demasiado útiles por sí mismos, pero 
combínelos como un formulario y ahora pueden hacer algo juntos.

La acumulación de moléculas a partir de átomos fomenta una mentalidad de "hacer una cosa y hacerlo bien".


	3.-Organismos

Las moléculas nos dan algunos bloques de construcción con los que trabajar, y ahora podemos combinarlos para 
formar organismos. Los organismos son grupos de moléculas que se unen para formar una sección 
distinta y relativamente compleja de una interfaz.

Los organismos pueden consistir en tipos de moléculas similares y / o diferentes. Por ejemplo, un organismo 
de cabecera puede constar de diversos componentes como un logotipo, navegación principal, formulario de 
búsqueda y lista de canales de redes sociales. Pero un organismo de “rejilla de productos” podría consistir 
en la misma molécula (posiblemente conteniendo una imagen de producto, título de producto y precio) repetida 
una y otra vez.

La acumulación de moléculas a organismos fomenta la creación de componentes autónomos, portátiles y reutilizables.


	4.-Plantillas

En la etapa de la plantilla, rompemos nuestra analogía química para entrar en un lenguaje que tenga 
más sentido para nuestros clientes y nuestro resultado final. Las plantillas consisten principalmente 
en grupos de organismos unidos para formar páginas. Es aquí donde comenzamos a ver cómo el diseño se une 
y comenzamos a ver cosas como el diseño en acción.

Las plantillas son muy concretas y proporcionan contexto a todas estas moléculas y organismos relativamente 
abstractos. Las plantillas también son donde los clientes comienzan a ver el diseño final en su lugar. 
En mi experiencia trabajando con esta metodología, las plantillas comienzan su vida como wireframes HTML, 
pero con el tiempo aumentan la fidelidad para convertirse en el producto final.


	5.-Paginas

Las páginas son instancias específicas de plantillas. Aquí, el contenido de marcador de posición se 
reemplaza con contenido representativo real para brindar una descripción precisa de lo que un usuario 
verá en última instancia.

Las páginas tienen el nivel más alto de fidelidad y, debido a que son las más tangibles, generalmente es 
donde la mayoría de las personas en el proceso pasan la mayor parte de su tiempo y en lo que giran la 
mayoría de las reseñas.

La etapa de la página es esencial, ya que es donde probamos la efectividad del sistema de diseño. Ver 
todo en contexto nos permite retroceder para modificar nuestras moléculas, organismos y plantillas para 
abordar mejor el contexto real del diseño.


¿Porque atomic design?

El diseño atómico proporciona una metodología clara para la elaboración de sistemas de diseño. Los clientes 
y los miembros del equipo pueden apreciar mejor el concepto de sistemas de diseño al ver realmente los 
pasos que se presentan frente a ellos.

El diseño atómico nos da la capacidad de pasar de lo abstracto a lo concreto. Debido a esto, podemos crear 
sistemas que promuevan la coherencia y la escalabilidad al mismo tiempo que muestran las cosas en su 
contexto final. Y al ensamblar en lugar de deconstruir, estamos creando un sistema desde el principio en 
lugar de seleccionar patrones después del hecho.







******************************************************************************

		Portals

Como crear un Popup con Portals: https://www.youtube.com/watch?v=LyLa7dU5tp8

Los portales proporcionan una forma de primera clase para convertir a los niños en un nodo DOM que 
existe fuera de la jerarquía DOM del componente principal.

	ReactDOM.createPortal(child, container)

El primer argumento ( child) es cualquier hijo React renderizable , como un elemento, cadena o fragmento. 
El segundo argumento ( container) es un elemento DOM.

USO 

Normalmente, cuando devuelve un elemento del método de representación de un componente, se 
monta en el DOM como un elemento secundario del nodo principal más cercano:

render() {
  // React mounts a new div and renders the children into it
  return (
    <div>
      {this.props.children}
    </div>
  );
}

Sin embargo, a veces es útil insertar un niño en una ubicación diferente en el DOM:

render() {
  // React does *not* create a new div. It renders the children into `domNode`.
  // `domNode` is any valid DOM node, regardless of its location in the DOM.
  return ReactDOM.createPortal(
    this.props.children,
    domNode
  );
}

Un caso de uso típico de los portales es cuando un componente padre tiene un 
estilo overflow: hidden o z-index, pero necesita que el hijo "salga" visualmente de su contenedor. 
Por ejemplo, cuadros de diálogo, tarjetas flotantes e información sobre herramientas.

Nota:

Cuando trabaje con portales, recuerde que administrar el enfoque del teclado se vuelve muy importante.

Para los diálogos modales, asegúrese de que todos puedan interactuar con ellos siguiendo las 
Prácticas de autoría modal WAI-ARIA .


	Evento burbujeante a través de portales

Aunque un portal puede estar en cualquier parte del árbol DOM, se comporta como un niño React normal en todos 
los demás aspectos. Las características como el contexto funcionan exactamente igual independientemente de si 
el niño es un portal, ya que el portal todavía existe en el árbol de React independientemente de la posición 
en el árbol DOM .

Esto incluye la propagación de eventos. Un evento disparado desde el interior de un portal se propagará a los 
ancestros en el árbol de React que lo contiene , incluso si esos elementos no son ancestros en el árbol DOM . 
Suponiendo la siguiente estructura HTML:

<html>
  <body>
    <div id="app-root"></div>
    <div id="modal-root"></div>
  </body>
</html>

Un Parentcomponente de #app-rootpodría capturar un evento burbujeante no detectado del nodo hermano #modal-root.

// These two containers are siblings in the DOM
const appRoot = document.getElementById('app-root');
const modalRoot = document.getElementById('modal-root');

class Modal extends React.Component {
  constructor(props) {
    super(props);
    this.el = document.createElement('div');
  }

  componentDidMount() {
    // The portal element is inserted in the DOM tree after
    // the Modal's children are mounted, meaning that children
    // will be mounted on a detached DOM node. If a child
    // component requires to be attached to the DOM tree
    // immediately when mounted, for example to measure a
    // DOM node, or uses 'autoFocus' in a descendant, add
    // state to Modal and only render the children when Modal
    // is inserted in the DOM tree.
    modalRoot.appendChild(this.el);
  }

  componentWillUnmount() {
    modalRoot.removeChild(this.el);
  }

  render() {
    return ReactDOM.createPortal(
      this.props.children,
      this.el
    );
  }
}

class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {clicks: 0};
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    // This will fire when the button in Child is clicked,
    // updating Parent's state, even though button
    // is not direct descendant in the DOM.
    this.setState(state => ({
      clicks: state.clicks + 1
    }));
  }

  render() {
    return (
      <div onClick={this.handleClick}>
        <p>Number of clicks: {this.state.clicks}</p>
        <p>
          Open up the browser DevTools
          to observe that the button
          is not a child of the div
          with the onClick handler.
        </p>
        <Modal>
          <Child />
        </Modal>
      </div>
    );
  }
}

function Child() {
  // The click event on this button will bubble up to parent,
  // because there is no 'onClick' attribute defined
  return (
    <div className="modal">
      <button>Click</button>
    </div>
  );
}

ReactDOM.render(<Parent />, appRoot);

La captura de un evento que surge de un portal en un componente principal permite el desarrollo de 
abstracciones más flexibles que no dependen inherentemente de los portales. Por ejemplo, si 
renderiza un <Modal />componente, el padre puede capturar sus eventos independientemente de si se 
implementa mediante portales.


Revisar: https://www.youtube.com/watch?v=cpBrvltVRNY


******************************************************************************
Routing



¿Qué proyecto debo elegir hoy?

React Router ofrecerá una ruta de migración incremental, pero @ reach / router se parece un poco más a la 
nueva API. Entonces:

Si solo tiene algunas rutas, es posible que desee elegir @ reach / router. La API @ reach / enrutador se parece 
un poco más a la nueva API, por lo que será más fácil migrar en una confirmación. No debería tomar más de una tarde.

Si tiene muchas rutas, especialmente con muchos componentes Routey anidados Switch, es posible que desee elegir 
React Router. Será 100% compatible con versiones anteriores, ofreciendo una ruta de migración incremental a 
las nuevas API basadas en enlaces.

Las API actuales de React Router y @ reach / router serán compatibles en el futuro previsible con correcciones 
de errores (al igual que hemos mantenido en silencio React Router v3 durante los últimos años). Entonces, 
si las cosas nuevas no son atractivas, no necesitará actualizar nada.




	BrowserRouter Component vs HashRouter Component 

BrowserRouter -> example.com/users || example.com/book/0

HashRouter -> example.com/index.html/#/users || example.com/index.html/#/book/0

They solve the same frontend issue, but the difference is how they consider the server will serve the contents








	División de código - Code-Splitting

Bundling - Agrupación

La mayoría de las aplicaciones de React tendrán sus archivos "empaquetados" usando herramientas como 
Webpack , Rollup o Browserify . La agrupación es el proceso de seguir archivos importados y fusionarlos 
en un solo archivo: un "paquete". Luego, este paquete se puede incluir en una página web para cargar una aplicación completa a la vez.

import()
La mejor manera de introducir la división de código en su aplicación es a través de la import()sintaxis dinámica .

Antes: 

	import { add } from './math';
	console.log(add(16, 26));

Despues:

	import("./math").then(math => {
	console.log(math.add(16, 26));
	});




	React lazy 


La React.lazyfunción le permite renderizar una importación dinámica como un componente regular.

Antes:

	import OtherComponent from './OtherComponent';

Después:

	const OtherComponent = React.lazy(() => import('./OtherComponent'));

Esto cargará automáticamente el paquete que contiene el OtherComponentcuando este componente se procese 
por primera vez.

React.lazytoma una función que debe llamar a una dinámica import(). Esto debe devolver un Promiseque se 
resuelve en un módulo con una defaultexportación que contiene un componente React.

El componente diferido debe representarse dentro de un Suspensecomponente, lo que nos permite mostrar algún 
contenido de respaldo (como un indicador de carga) mientras esperamos que se cargue el componente diferido.

import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}



El fallback accesorio acepta cualquier elemento de React que desee renderizar mientras espera que se 
cargue el componente. Puede colocar el Suspensecomponente en cualquier lugar por encima del componente 
diferido. Incluso puede envolver varios componentes perezosos con un solo Suspensecomponente.

import React, { Suspense } from 'react';

const OtherComponent = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./AnotherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </div>
  );
}



	Division de codsigo basada en ruta 

Aquí hay un ejemplo de cómo configurar la división de código basado en rutas en su aplicación 
utilizando bibliotecas como React Router con React.lazy.

import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';

const Home = lazy(() => import('./routes/Home'));
const About = lazy(() => import('./routes/About'));

const App = () => (
  <Router>
    <Suspense fallback={<div>Loading...</div>}>
      <Switch>
        <Route exact path="/" component={Home}/>
        <Route path="/about" component={About}/>
      </Switch>
    </Suspense>
  </Router>
);

Ejemplo:

import React, {lazy, Suspense} from 'react;

//En lugar del hacer un import lo hacemos con lazy =>
const AvatarComponent = lazy(() => import('./ladireccion'));

export const renderLoader = () => (
	<Suspense fallback={<p>...Loading...</p>}>
		<AvatarComponent/>
	</Suspense>
)


























